// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: umee/leverage/v1/query.proto

package types

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryParams defines the request structure for the Params gRPC service
// handler.
type QueryParams struct {
}

func (m *QueryParams) Reset()         { *m = QueryParams{} }
func (m *QueryParams) String() string { return proto.CompactTextString(m) }
func (*QueryParams) ProtoMessage()    {}
func (*QueryParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{0}
}
func (m *QueryParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParams.Merge(m, src)
}
func (m *QueryParams) XXX_Size() int {
	return m.Size()
}
func (m *QueryParams) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParams.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParams proto.InternalMessageInfo

// QueryParamsResponse defines the response structure for the Params gRPC
// service handler.
type QueryParamsResponse struct {
	Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *QueryParamsResponse) Reset()         { *m = QueryParamsResponse{} }
func (m *QueryParamsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryParamsResponse) ProtoMessage()    {}
func (*QueryParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{1}
}
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}
func (m *QueryParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

// QueryRegisteredTokens defines the request structure for the RegisteredTokens
// gRPC service handler.
type QueryRegisteredTokens struct {
	BaseDenom string `protobuf:"bytes,1,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom,omitempty"`
}

func (m *QueryRegisteredTokens) Reset()         { *m = QueryRegisteredTokens{} }
func (m *QueryRegisteredTokens) String() string { return proto.CompactTextString(m) }
func (*QueryRegisteredTokens) ProtoMessage()    {}
func (*QueryRegisteredTokens) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{2}
}
func (m *QueryRegisteredTokens) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRegisteredTokens) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRegisteredTokens.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRegisteredTokens) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRegisteredTokens.Merge(m, src)
}
func (m *QueryRegisteredTokens) XXX_Size() int {
	return m.Size()
}
func (m *QueryRegisteredTokens) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRegisteredTokens.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRegisteredTokens proto.InternalMessageInfo

// QueryRegisteredTokensResponse defines the response structure for the
// RegisteredTokens gRPC service handler.
type QueryRegisteredTokensResponse struct {
	Registry []Token `protobuf:"bytes,1,rep,name=registry,proto3" json:"registry"`
}

func (m *QueryRegisteredTokensResponse) Reset()         { *m = QueryRegisteredTokensResponse{} }
func (m *QueryRegisteredTokensResponse) String() string { return proto.CompactTextString(m) }
func (*QueryRegisteredTokensResponse) ProtoMessage()    {}
func (*QueryRegisteredTokensResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{3}
}
func (m *QueryRegisteredTokensResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRegisteredTokensResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRegisteredTokensResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRegisteredTokensResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRegisteredTokensResponse.Merge(m, src)
}
func (m *QueryRegisteredTokensResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryRegisteredTokensResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRegisteredTokensResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRegisteredTokensResponse proto.InternalMessageInfo

// QueryRegisteredTokensWithMarkets defines the request structure for the RegisteredTokenMarkets
// gRPC service handler.
type QueryRegisteredTokensWithMarkets struct {
}

func (m *QueryRegisteredTokensWithMarkets) Reset()         { *m = QueryRegisteredTokensWithMarkets{} }
func (m *QueryRegisteredTokensWithMarkets) String() string { return proto.CompactTextString(m) }
func (*QueryRegisteredTokensWithMarkets) ProtoMessage()    {}
func (*QueryRegisteredTokensWithMarkets) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{4}
}
func (m *QueryRegisteredTokensWithMarkets) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRegisteredTokensWithMarkets) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRegisteredTokensWithMarkets.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRegisteredTokensWithMarkets) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRegisteredTokensWithMarkets.Merge(m, src)
}
func (m *QueryRegisteredTokensWithMarkets) XXX_Size() int {
	return m.Size()
}
func (m *QueryRegisteredTokensWithMarkets) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRegisteredTokensWithMarkets.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRegisteredTokensWithMarkets proto.InternalMessageInfo

// QueryRegisteredTokensWithMarketsResponse defines the response structure for the
// RegisteredTokensWithMarkets gRPC service handler.
type QueryRegisteredTokensWithMarketsResponse struct {
	Markets []TokenMarket `protobuf:"bytes,1,rep,name=markets,proto3" json:"markets"`
}

func (m *QueryRegisteredTokensWithMarketsResponse) Reset() {
	*m = QueryRegisteredTokensWithMarketsResponse{}
}
func (m *QueryRegisteredTokensWithMarketsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryRegisteredTokensWithMarketsResponse) ProtoMessage()    {}
func (*QueryRegisteredTokensWithMarketsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{5}
}
func (m *QueryRegisteredTokensWithMarketsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRegisteredTokensWithMarketsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRegisteredTokensWithMarketsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRegisteredTokensWithMarketsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRegisteredTokensWithMarketsResponse.Merge(m, src)
}
func (m *QueryRegisteredTokensWithMarketsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryRegisteredTokensWithMarketsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRegisteredTokensWithMarketsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRegisteredTokensWithMarketsResponse proto.InternalMessageInfo

// TokenMarket is a token and its market summary.
type TokenMarket struct {
	// Token is a registered token and its parameters.
	Token Token `protobuf:"bytes,1,opt,name=token,proto3" json:"token"`
	// Market is the market summary for the token.
	Market QueryMarketSummaryResponse `protobuf:"bytes,2,opt,name=market,proto3" json:"market"`
}

func (m *TokenMarket) Reset()         { *m = TokenMarket{} }
func (m *TokenMarket) String() string { return proto.CompactTextString(m) }
func (*TokenMarket) ProtoMessage()    {}
func (*TokenMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{6}
}
func (m *TokenMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenMarket.Merge(m, src)
}
func (m *TokenMarket) XXX_Size() int {
	return m.Size()
}
func (m *TokenMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenMarket.DiscardUnknown(m)
}

var xxx_messageInfo_TokenMarket proto.InternalMessageInfo

// QuerySpecialAssets defines the request structure for the SpecialAssets
// gRPC service handler.
type QuerySpecialAssets struct {
	// denom can be used to query only pairs affecting a specific asset
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
}

func (m *QuerySpecialAssets) Reset()         { *m = QuerySpecialAssets{} }
func (m *QuerySpecialAssets) String() string { return proto.CompactTextString(m) }
func (*QuerySpecialAssets) ProtoMessage()    {}
func (*QuerySpecialAssets) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{7}
}
func (m *QuerySpecialAssets) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpecialAssets) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpecialAssets.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySpecialAssets) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpecialAssets.Merge(m, src)
}
func (m *QuerySpecialAssets) XXX_Size() int {
	return m.Size()
}
func (m *QuerySpecialAssets) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpecialAssets.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpecialAssets proto.InternalMessageInfo

// QuerySpecialAssetsResponse defines the response structure for the
// SpecialAssets gRPC service handler.
type QuerySpecialAssetsResponse struct {
	Pairs []SpecialAssetPair `protobuf:"bytes,1,rep,name=pairs,proto3" json:"pairs"`
}

func (m *QuerySpecialAssetsResponse) Reset()         { *m = QuerySpecialAssetsResponse{} }
func (m *QuerySpecialAssetsResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySpecialAssetsResponse) ProtoMessage()    {}
func (*QuerySpecialAssetsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{8}
}
func (m *QuerySpecialAssetsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpecialAssetsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpecialAssetsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySpecialAssetsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpecialAssetsResponse.Merge(m, src)
}
func (m *QuerySpecialAssetsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySpecialAssetsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpecialAssetsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpecialAssetsResponse proto.InternalMessageInfo

// QueryMarketSummary defines the request structure for the MarketSummary gRPC service handler.
type QueryMarketSummary struct {
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
}

func (m *QueryMarketSummary) Reset()         { *m = QueryMarketSummary{} }
func (m *QueryMarketSummary) String() string { return proto.CompactTextString(m) }
func (*QueryMarketSummary) ProtoMessage()    {}
func (*QueryMarketSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{9}
}
func (m *QueryMarketSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMarketSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMarketSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMarketSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMarketSummary.Merge(m, src)
}
func (m *QueryMarketSummary) XXX_Size() int {
	return m.Size()
}
func (m *QueryMarketSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMarketSummary.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMarketSummary proto.InternalMessageInfo

// QueryMarketSummaryResponse defines the response structure for the MarketSummary gRPC service handler.
type QueryMarketSummaryResponse struct {
	// Symbol Denom is the human-readable representation of a token denom, for example "UMEE" or "ATOM".
	SymbolDenom string `protobuf:"bytes,1,opt,name=symbol_denom,json=symbolDenom,proto3" json:"symbol_denom,omitempty"`
	// Exponent is the power of ten required to get from base denom to symbol denom. For example, an exponent of 6 means 10^6 uumee = 1 UMEE.
	Exponent uint32 `protobuf:"varint,2,opt,name=exponent,proto3" json:"exponent,omitempty"`
	// Oracle Price is the current USD value of a token. Oracle price is nil when the oracle is down.
	OraclePrice *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=oracle_price,json=oraclePrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"oracle_price,omitempty"`
	// uToken Exchange Rate is the amount of base tokens received when withdrawing 1 uToken. For example, a uToken exchange rate of 1.5 means a supplier receives 3 uumee for every 2 u/uumee they wish to withdraw. The same applies in reverse: supplying 3 uumee would award 2 u/uumee at that time.
	UTokenExchangeRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=uToken_exchange_rate,json=uTokenExchangeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"utoken_exchange_rate"`
	// Supply APY is the current interest rate suppliers are receiving for their deposits. For example, 0.11 would mean 11% APY. Supply APY is always less than borrow APY.
	Supply_APY github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=supply_APY,json=supplyAPY,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"supply_apy"`
	// Borrow APY is the current interest rate borrowers are being charged on their loans. For example, 0.2 would mean 20% APY.
	Borrow_APY github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=borrow_APY,json=borrowAPY,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"borrow_apy"`
	// Supplied is the total amount of tokens supplied to the the system by all suppliers, including any interest earned. This includes that tokens which have been borrowed out or enabled as collateral, but excludes reserves. Supplied is denominated in base tokens, so exponent must be applied to convert to symbol denom.
	Supplied github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,7,opt,name=supplied,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"supplied"`
	// Reserved is the total amount of tokens held in reserve by the module for emergencies. Reserves are always excluded from total supply, borrow, collateral, and liqduidity queries. Reserves are denominated in base tokens, so exponent must be applied to convert to symbol denom.
	Reserved github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,8,opt,name=reserved,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"reserved"`
	// Collateral is the total amount of uTokens collateralized by all borrowers. Collateral is denominated in uTokenso, so both uToken exchange rate and exponent must also be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee and uToken exchange rate is 1.2, then 5 UMEE have been collateralized.
	Collateral github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,9,opt,name=collateral,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"collateral"`
	// Borrowed is the total amount of debt in this token held across all borrowers. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
	Borrowed github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,10,opt,name=borrowed,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"borrowed"`
	// Liquidity is the amount of a token that has been supplied but not yet borrowed or reserved. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
	Liquidity github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,11,opt,name=liquidity,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"liquidity"`
	// Maximum Borrow is the amount of a token that is available for borrowing, including that which has already been borrowed out. This amount is less than total supply due to safety limits. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if borrowed is 3000000 uumee and maximum borrow is 4000000 uumee, then 1 UMEE is currently available for borrowing.
	MaximumBorrow github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,12,opt,name=maximum_borrow,json=maximumBorrow,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"maximum_borrow"`
	// Maximum Collateral is the amount of a token that can be collateralized, including that which is already collateral. This amount is less than total supply due to safety limits. It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee, uToken exchange rate is 1.2, and maximum borrow is 7000000 uumee, then a maximum of 2 additional UMEE is permitted to be collateralized.
	MaximumCollateral github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,13,opt,name=maximum_collateral,json=maximumCollateral,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"maximum_collateral"`
	// Minimum Liquidity is the minimum amount of liquidity in the module required by safety limits, based on the current collateral. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if liquidity is 9000000 uumee and minimum liquidity is 8000000 uumee, then a maximum of 1 additional UMEE is currently available for borrowing or withdrawal.
	MinimumLiquidity github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,14,opt,name=minimum_liquidity,json=minimumLiquidity,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"minimum_liquidity"`
	// uToken Supply is the total amount of a base token's associated uToken in circulation.
	UTokenSupply github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,15,opt,name=uToken_supply,json=uTokenSupply,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"utoken_supply"`
	// Available Borrow is the maximum additional amount of base tokens than can be borrowed based on current liquidity and system safety limits. It can also be calculated by MIN(maximum_borrow - borrowed, liquidity - minimum_liquidity). It is denominated in base tokens, so exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and borrowing is temporarily unavailable.
	AvailableBorrow github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,16,opt,name=available_borrow,json=availableBorrow,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"available_borrow"`
	// Available Withdraw is the maximum amount of uTokens than can currently be withdrawn based on liquidity and system safety limits. It can also be calculated by (liquidity - minimum_liquidity). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and withdrawal is temporarily unavailable.
	AvailableWithdraw github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,17,opt,name=available_withdraw,json=availableWithdraw,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"available_withdraw"`
	// Available Collateralize is the maximum additional amount of uTokens than can be collateralized based on current liquidity and system safety limits. It can also be calculated by (maximum_collateral, - collateral). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and additional collateral cannot be created until more liquidity is present.
	AvailableCollateralize github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,18,opt,name=available_collateralize,json=availableCollateralize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"available_collateralize"`
	// Oracle Historic Price is the historic USD value of a token. Historic price is defined as the median of the last N historic median prices from the oracle module, with N being this token's HistoricMedians in the leverage registry. Current price is used if required medians is zero. Price is nil when the oracle is down or insufficient historic medians are available.
	OracleHistoricPrice *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,19,opt,name=oracle_historic_price,json=oracleHistoricPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"oracle_historic_price,omitempty"`
	Errors              string                                  `protobuf:"bytes,20,opt,name=errors,proto3" json:"errors,omitempty"`
}

func (m *QueryMarketSummaryResponse) Reset()         { *m = QueryMarketSummaryResponse{} }
func (m *QueryMarketSummaryResponse) String() string { return proto.CompactTextString(m) }
func (*QueryMarketSummaryResponse) ProtoMessage()    {}
func (*QueryMarketSummaryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{10}
}
func (m *QueryMarketSummaryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMarketSummaryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMarketSummaryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMarketSummaryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMarketSummaryResponse.Merge(m, src)
}
func (m *QueryMarketSummaryResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryMarketSummaryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMarketSummaryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMarketSummaryResponse proto.InternalMessageInfo

// QueryAccountBalances defines the request structure for the AccountBalances gRPC service handler.
type QueryAccountBalances struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *QueryAccountBalances) Reset()         { *m = QueryAccountBalances{} }
func (m *QueryAccountBalances) String() string { return proto.CompactTextString(m) }
func (*QueryAccountBalances) ProtoMessage()    {}
func (*QueryAccountBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{11}
}
func (m *QueryAccountBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAccountBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAccountBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAccountBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAccountBalances.Merge(m, src)
}
func (m *QueryAccountBalances) XXX_Size() int {
	return m.Size()
}
func (m *QueryAccountBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAccountBalances.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAccountBalances proto.InternalMessageInfo

// QueryAccountBalancesResponse defines the response structure for the AccountBalances gRPC service handler.
type QueryAccountBalancesResponse struct {
	// Supplied contains all tokens the account has supplied, including interest earned. It is denominated in base tokens, so exponent from each coin's registered_tokens entry must be applied to convert to symbol denom.
	Supplied github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=supplied,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"supplied"`
	// Collateral contains all uTokens the account has collateralized. It is denominated in uTokens, so both exponent and uToken exchange rate from each coin's market_summary must be applied to convert to base token symbol denom.
	Collateral github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=collateral,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"collateral"`
	// Borrowed contains all tokens the account has borrowed, including interest owed. It is denominated in base tokens, so exponent from each coin's registered_tokens entry must be applied to convert to symbol denom.
	Borrowed github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=borrowed,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"borrowed"`
}

func (m *QueryAccountBalancesResponse) Reset()         { *m = QueryAccountBalancesResponse{} }
func (m *QueryAccountBalancesResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAccountBalancesResponse) ProtoMessage()    {}
func (*QueryAccountBalancesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{12}
}
func (m *QueryAccountBalancesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAccountBalancesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAccountBalancesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAccountBalancesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAccountBalancesResponse.Merge(m, src)
}
func (m *QueryAccountBalancesResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAccountBalancesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAccountBalancesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAccountBalancesResponse proto.InternalMessageInfo

// QueryAccountSummary defines the request structure for the AccountSummary gRPC service handler.
type QueryAccountSummary struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *QueryAccountSummary) Reset()         { *m = QueryAccountSummary{} }
func (m *QueryAccountSummary) String() string { return proto.CompactTextString(m) }
func (*QueryAccountSummary) ProtoMessage()    {}
func (*QueryAccountSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{13}
}
func (m *QueryAccountSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAccountSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAccountSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAccountSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAccountSummary.Merge(m, src)
}
func (m *QueryAccountSummary) XXX_Size() int {
	return m.Size()
}
func (m *QueryAccountSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAccountSummary.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAccountSummary proto.InternalMessageInfo

// QueryAccountSummaryResponse defines the response structure for the AccountSummary gRPC service handler.
type QueryAccountSummaryResponse struct {
	// Supplied Value is the sum of the USD value of all tokens the account has supplied, including interest earned.
	// It uses the lower of spot or historic price for each token.
	// Computation skips assets which are missing oracle prices, potentially resulting in a lower supplied
	// value than if prices were all available.
	SuppliedValue github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=supplied_value,json=suppliedValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"supplied_value"`
	// Collateral Value is the sum of the USD value of all uTokens the account has collateralized.
	// It uses the lower of spot or historic price for each token.
	// Computation skips collateral which is missing an oracle price, potentially resulting in a lower collateral
	// value than if prices were all available.
	CollateralValue github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=collateral_value,json=collateralValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"collateral_value"`
	// Borrowed Value is the sum of the USD value of all tokens the account has borrowed, including interest owed.
	// It uses the higher of spot or historic price for each token.
	// Computation skips borrows which are missing oracle prices, potentially resulting in a lower borrowed
	// value than if prices were all available.
	BorrowedValue github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=borrowed_value,json=borrowedValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"borrowed_value"`
	// Borrow Limit is the maximum Borrowed Value the account is allowed to reach through direct borrowing.
	// The lower of spot or historic price for each collateral token is used when calculating borrow limits.
	// Computation skips collateral which is missing an oracle price, potentially resulting in a lower borrow
	// limit than if prices were all available. Will be null if an oracle price required for computation is
	// missing.
	BorrowLimit *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=borrow_limit,json=borrowLimit,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"borrow_limit,omitempty"`
	// Liquidation Threshold is the Borrowed Value at which the account becomes eligible for liquidation.
	// Computation skips borrows which are missing an oracle price, potentially resulting in a lower borrow
	// limit than if prices were all available. Will be null if an oracle price required for computation is
	// missing.
	LiquidationThreshold *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=liquidation_threshold,json=liquidationThreshold,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_threshold,omitempty"`
	// Spot Supplied Value is supplied value but always uses the most recent available spot prices.
	SpotSuppliedValue github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=spot_supplied_value,json=spotSuppliedValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"spot_supplied_value"`
	// Spot Collateral Value is collateral value but always uses the most recent available spot prices.
	SpotCollateralValue github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=spot_collateral_value,json=spotCollateralValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"spot_collateral_value"`
	// Spot Borrowed Value is borrowed value but always uses the most recent available spot prices.
	SpotBorrowedValue github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=spot_borrowed_value,json=spotBorrowedValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"spot_borrowed_value"`
}

func (m *QueryAccountSummaryResponse) Reset()         { *m = QueryAccountSummaryResponse{} }
func (m *QueryAccountSummaryResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAccountSummaryResponse) ProtoMessage()    {}
func (*QueryAccountSummaryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{14}
}
func (m *QueryAccountSummaryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAccountSummaryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAccountSummaryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAccountSummaryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAccountSummaryResponse.Merge(m, src)
}
func (m *QueryAccountSummaryResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAccountSummaryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAccountSummaryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAccountSummaryResponse proto.InternalMessageInfo

// QueryLiquidationTargets defines the request structure for the LiquidationTargets gRPC service handler.
type QueryLiquidationTargets struct {
}

func (m *QueryLiquidationTargets) Reset()         { *m = QueryLiquidationTargets{} }
func (m *QueryLiquidationTargets) String() string { return proto.CompactTextString(m) }
func (*QueryLiquidationTargets) ProtoMessage()    {}
func (*QueryLiquidationTargets) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{15}
}
func (m *QueryLiquidationTargets) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLiquidationTargets) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryLiquidationTargets.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryLiquidationTargets) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLiquidationTargets.Merge(m, src)
}
func (m *QueryLiquidationTargets) XXX_Size() int {
	return m.Size()
}
func (m *QueryLiquidationTargets) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLiquidationTargets.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLiquidationTargets proto.InternalMessageInfo

// QueryLiquidationTargetsResponse defines the response structure for the LiquidationTargets gRPC service handler.
type QueryLiquidationTargetsResponse struct {
	// Targets are the addresses of borrowers eligible for liquidation.
	Targets []string `protobuf:"bytes,1,rep,name=targets,proto3" json:"targets,omitempty"`
}

func (m *QueryLiquidationTargetsResponse) Reset()         { *m = QueryLiquidationTargetsResponse{} }
func (m *QueryLiquidationTargetsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryLiquidationTargetsResponse) ProtoMessage()    {}
func (*QueryLiquidationTargetsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{16}
}
func (m *QueryLiquidationTargetsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLiquidationTargetsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryLiquidationTargetsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryLiquidationTargetsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLiquidationTargetsResponse.Merge(m, src)
}
func (m *QueryLiquidationTargetsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryLiquidationTargetsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLiquidationTargetsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLiquidationTargetsResponse proto.InternalMessageInfo

// QueryBadDebts defines the request structure for the
// BedDebts gRPC service handler.
type QueryBadDebts struct {
}

func (m *QueryBadDebts) Reset()         { *m = QueryBadDebts{} }
func (m *QueryBadDebts) String() string { return proto.CompactTextString(m) }
func (*QueryBadDebts) ProtoMessage()    {}
func (*QueryBadDebts) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{17}
}
func (m *QueryBadDebts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBadDebts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBadDebts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBadDebts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBadDebts.Merge(m, src)
}
func (m *QueryBadDebts) XXX_Size() int {
	return m.Size()
}
func (m *QueryBadDebts) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBadDebts.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBadDebts proto.InternalMessageInfo

// QueryBadDebtsResponse defines the response structure for the BedDebts gRPC service handler.
type QueryBadDebtsResponse struct {
	// Targets are borrow positions currently marked for bad debt repayment. Each contains an Address and a Denom.
	Targets []BadDebt `protobuf:"bytes,1,rep,name=targets,proto3" json:"targets"`
}

func (m *QueryBadDebtsResponse) Reset()         { *m = QueryBadDebtsResponse{} }
func (m *QueryBadDebtsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryBadDebtsResponse) ProtoMessage()    {}
func (*QueryBadDebtsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{18}
}
func (m *QueryBadDebtsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBadDebtsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBadDebtsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBadDebtsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBadDebtsResponse.Merge(m, src)
}
func (m *QueryBadDebtsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryBadDebtsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBadDebtsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBadDebtsResponse proto.InternalMessageInfo

// QueryMaxWithdraw defines the request structure for the MaxWithdraw gRPC service handler.
type QueryMaxWithdraw struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// denom is the base token denom associated with the uToken to withdraw.
	// empty denom will query all registered tokens.
	Denom string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
}

func (m *QueryMaxWithdraw) Reset()         { *m = QueryMaxWithdraw{} }
func (m *QueryMaxWithdraw) String() string { return proto.CompactTextString(m) }
func (*QueryMaxWithdraw) ProtoMessage()    {}
func (*QueryMaxWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{19}
}
func (m *QueryMaxWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMaxWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMaxWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMaxWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMaxWithdraw.Merge(m, src)
}
func (m *QueryMaxWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *QueryMaxWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMaxWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMaxWithdraw proto.InternalMessageInfo

// QueryMaxWithdrawResponse defines the response structure for the MaxWithdraw gRPC service handler.
type QueryMaxWithdrawResponse struct {
	// uTokens is the maximum amount of uTokens that can be withdrawn
	UTokens github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=uTokens,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"uTokens"`
	// Tokens is the equivalent of max uTokens converted to base tokens
	Tokens github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=tokens,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"tokens"`
}

func (m *QueryMaxWithdrawResponse) Reset()         { *m = QueryMaxWithdrawResponse{} }
func (m *QueryMaxWithdrawResponse) String() string { return proto.CompactTextString(m) }
func (*QueryMaxWithdrawResponse) ProtoMessage()    {}
func (*QueryMaxWithdrawResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{20}
}
func (m *QueryMaxWithdrawResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMaxWithdrawResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMaxWithdrawResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMaxWithdrawResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMaxWithdrawResponse.Merge(m, src)
}
func (m *QueryMaxWithdrawResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryMaxWithdrawResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMaxWithdrawResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMaxWithdrawResponse proto.InternalMessageInfo

// QueryMaxBorrow defines the request structure for the MaxBorrow gRPC service handler.
type QueryMaxBorrow struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// denom is the base token denom to borrow.
	// empty denom will query all registered tokens.
	Denom string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
}

func (m *QueryMaxBorrow) Reset()         { *m = QueryMaxBorrow{} }
func (m *QueryMaxBorrow) String() string { return proto.CompactTextString(m) }
func (*QueryMaxBorrow) ProtoMessage()    {}
func (*QueryMaxBorrow) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{21}
}
func (m *QueryMaxBorrow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMaxBorrow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMaxBorrow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMaxBorrow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMaxBorrow.Merge(m, src)
}
func (m *QueryMaxBorrow) XXX_Size() int {
	return m.Size()
}
func (m *QueryMaxBorrow) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMaxBorrow.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMaxBorrow proto.InternalMessageInfo

// QueryMaxBorrowResponse defines the response structure for the MaxBorrow gRPC service handler.
type QueryMaxBorrowResponse struct {
	// Tokens is the maximum amount of tokens that can be borrowed
	Tokens github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=tokens,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"tokens"`
}

func (m *QueryMaxBorrowResponse) Reset()         { *m = QueryMaxBorrowResponse{} }
func (m *QueryMaxBorrowResponse) String() string { return proto.CompactTextString(m) }
func (*QueryMaxBorrowResponse) ProtoMessage()    {}
func (*QueryMaxBorrowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{22}
}
func (m *QueryMaxBorrowResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMaxBorrowResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMaxBorrowResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMaxBorrowResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMaxBorrowResponse.Merge(m, src)
}
func (m *QueryMaxBorrowResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryMaxBorrowResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMaxBorrowResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMaxBorrowResponse proto.InternalMessageInfo

// QueryInspect defines the request structure for the Inspect gRPC service handler.
type QueryInspect struct {
	// Symbol selects a symbol denom to sort accounts by borrowed value. Use "all" or empty string to show all.
	Symbol string `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// Borrowed is the minimum USD value an account must have borrowed to show. Use 0 to show all.
	Borrowed float64 `protobuf:"fixed64,2,opt,name=borrowed,proto3" json:"borrowed,omitempty"`
	// Collateral is the minimum USD value of collateral an account must have to show. Use 0 to show all.
	Collateral float64 `protobuf:"fixed64,3,opt,name=collateral,proto3" json:"collateral,omitempty"`
	// Danger is the minimum progress toward liquidation an account must have to show. Use 0 to show all.
	// Measured as the ratio (borrowed value / liquidation threshold), where > 1 is liquidation-eligible.
	Danger float64 `protobuf:"fixed64,4,opt,name=danger,proto3" json:"danger,omitempty"`
	// LTV is the minimum ratio (borrowed value / collateral value) an account must have to show. Use 0 to show all.
	Ltv float64 `protobuf:"fixed64,5,opt,name=ltv,proto3" json:"ltv,omitempty"`
}

func (m *QueryInspect) Reset()         { *m = QueryInspect{} }
func (m *QueryInspect) String() string { return proto.CompactTextString(m) }
func (*QueryInspect) ProtoMessage()    {}
func (*QueryInspect) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{23}
}
func (m *QueryInspect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryInspect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryInspect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryInspect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryInspect.Merge(m, src)
}
func (m *QueryInspect) XXX_Size() int {
	return m.Size()
}
func (m *QueryInspect) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryInspect.DiscardUnknown(m)
}

var xxx_messageInfo_QueryInspect proto.InternalMessageInfo

// QueryInspectAccount defines the request structure for the InspectAccount gRPC service handler.
type QueryInspectAccount struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *QueryInspectAccount) Reset()         { *m = QueryInspectAccount{} }
func (m *QueryInspectAccount) String() string { return proto.CompactTextString(m) }
func (*QueryInspectAccount) ProtoMessage()    {}
func (*QueryInspectAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{24}
}
func (m *QueryInspectAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryInspectAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryInspectAccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryInspectAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryInspectAccount.Merge(m, src)
}
func (m *QueryInspectAccount) XXX_Size() int {
	return m.Size()
}
func (m *QueryInspectAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryInspectAccount.DiscardUnknown(m)
}

var xxx_messageInfo_QueryInspectAccount proto.InternalMessageInfo

// QueryInspectResponse defines the response structure for the Inspect gRPC service handler.
type QueryInspectResponse struct {
	Borrowers []InspectAccount `protobuf:"bytes,1,rep,name=borrowers,proto3" json:"borrowers"`
	// Failures is a list of addresses for which the position calculation failed.
	Failures []string `protobuf:"bytes,2,rep,name=failures,proto3" json:"failures,omitempty"`
}

func (m *QueryInspectResponse) Reset()         { *m = QueryInspectResponse{} }
func (m *QueryInspectResponse) String() string { return proto.CompactTextString(m) }
func (*QueryInspectResponse) ProtoMessage()    {}
func (*QueryInspectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{25}
}
func (m *QueryInspectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryInspectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryInspectResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryInspectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryInspectResponse.Merge(m, src)
}
func (m *QueryInspectResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryInspectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryInspectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryInspectResponse proto.InternalMessageInfo

// QueryInspectAccountResponse defines the response structure for the InspectAccount gRPC service handler.
type QueryInspectAccountResponse struct {
	Borrower InspectAccount `protobuf:"bytes,1,opt,name=borrower,proto3" json:"borrower"`
}

func (m *QueryInspectAccountResponse) Reset()         { *m = QueryInspectAccountResponse{} }
func (m *QueryInspectAccountResponse) String() string { return proto.CompactTextString(m) }
func (*QueryInspectAccountResponse) ProtoMessage()    {}
func (*QueryInspectAccountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{26}
}
func (m *QueryInspectAccountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryInspectAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryInspectAccountResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryInspectAccountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryInspectAccountResponse.Merge(m, src)
}
func (m *QueryInspectAccountResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryInspectAccountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryInspectAccountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryInspectAccountResponse proto.InternalMessageInfo

// InspectAccount contains risk and balance info for a single account for the inspector query.
type InspectAccount struct {
	// Address of a borrower
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// USD totals of borrower's collateral, debt, and liquidation threshold.
	Analysis *RiskInfo `protobuf:"bytes,2,opt,name=analysis,proto3" json:"analysis,omitempty"`
	// Collateral and borrowed tokens, denoted in human-readable symbol denom instead of ibc denom.
	Position *DecBalances `protobuf:"bytes,3,opt,name=position,proto3" json:"position,omitempty"`
	// Info is a string which can be used to report additional information of any type.
	// UNSTABLE: We do not guarantee consistency of any data structures contained within the string.
	Info string `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *InspectAccount) Reset()         { *m = InspectAccount{} }
func (m *InspectAccount) String() string { return proto.CompactTextString(m) }
func (*InspectAccount) ProtoMessage()    {}
func (*InspectAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{27}
}
func (m *InspectAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectAccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectAccount.Merge(m, src)
}
func (m *InspectAccount) XXX_Size() int {
	return m.Size()
}
func (m *InspectAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectAccount.DiscardUnknown(m)
}

var xxx_messageInfo_InspectAccount proto.InternalMessageInfo

// RiskInfo defines a borrower's account health without requiring sdk.Dec formatting.
type RiskInfo struct {
	// Borrowed is account's borrowed value in USD.
	Borrowed float64 `protobuf:"fixed64,1,opt,name=Borrowed,proto3" json:"Borrowed,omitempty"`
	// Liquidation is account's liquidation threshold in USD.
	Liquidation float64 `protobuf:"fixed64,2,opt,name=Liquidation,proto3" json:"Liquidation,omitempty"`
	// Value is account's collateral value in USD.
	Value float64 `protobuf:"fixed64,3,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *RiskInfo) Reset()         { *m = RiskInfo{} }
func (m *RiskInfo) String() string { return proto.CompactTextString(m) }
func (*RiskInfo) ProtoMessage()    {}
func (*RiskInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{28}
}
func (m *RiskInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RiskInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RiskInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RiskInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RiskInfo.Merge(m, src)
}
func (m *RiskInfo) XXX_Size() int {
	return m.Size()
}
func (m *RiskInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RiskInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RiskInfo proto.InternalMessageInfo

// DecBalances contains an account's position denoted in symbol denom tokens.
type DecBalances struct {
	// Collateral contains all uTokens the account has collateralized. It has been converted from uTokens to tokens.
	Collateral github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,1,rep,name=collateral,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"collateral"`
	// Borrowed contains all tokens the account has borrowed, including interest owed.
	Borrowed github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,2,rep,name=borrowed,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"borrowed"`
}

func (m *DecBalances) Reset()         { *m = DecBalances{} }
func (m *DecBalances) String() string { return proto.CompactTextString(m) }
func (*DecBalances) ProtoMessage()    {}
func (*DecBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e8137dcabb0ccc7, []int{29}
}
func (m *DecBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecBalances.Merge(m, src)
}
func (m *DecBalances) XXX_Size() int {
	return m.Size()
}
func (m *DecBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_DecBalances.DiscardUnknown(m)
}

var xxx_messageInfo_DecBalances proto.InternalMessageInfo

func init() {
	proto.RegisterType((*QueryParams)(nil), "umee.leverage.v1.QueryParams")
	proto.RegisterType((*QueryParamsResponse)(nil), "umee.leverage.v1.QueryParamsResponse")
	proto.RegisterType((*QueryRegisteredTokens)(nil), "umee.leverage.v1.QueryRegisteredTokens")
	proto.RegisterType((*QueryRegisteredTokensResponse)(nil), "umee.leverage.v1.QueryRegisteredTokensResponse")
	proto.RegisterType((*QueryRegisteredTokensWithMarkets)(nil), "umee.leverage.v1.QueryRegisteredTokensWithMarkets")
	proto.RegisterType((*QueryRegisteredTokensWithMarketsResponse)(nil), "umee.leverage.v1.QueryRegisteredTokensWithMarketsResponse")
	proto.RegisterType((*TokenMarket)(nil), "umee.leverage.v1.TokenMarket")
	proto.RegisterType((*QuerySpecialAssets)(nil), "umee.leverage.v1.QuerySpecialAssets")
	proto.RegisterType((*QuerySpecialAssetsResponse)(nil), "umee.leverage.v1.QuerySpecialAssetsResponse")
	proto.RegisterType((*QueryMarketSummary)(nil), "umee.leverage.v1.QueryMarketSummary")
	proto.RegisterType((*QueryMarketSummaryResponse)(nil), "umee.leverage.v1.QueryMarketSummaryResponse")
	proto.RegisterType((*QueryAccountBalances)(nil), "umee.leverage.v1.QueryAccountBalances")
	proto.RegisterType((*QueryAccountBalancesResponse)(nil), "umee.leverage.v1.QueryAccountBalancesResponse")
	proto.RegisterType((*QueryAccountSummary)(nil), "umee.leverage.v1.QueryAccountSummary")
	proto.RegisterType((*QueryAccountSummaryResponse)(nil), "umee.leverage.v1.QueryAccountSummaryResponse")
	proto.RegisterType((*QueryLiquidationTargets)(nil), "umee.leverage.v1.QueryLiquidationTargets")
	proto.RegisterType((*QueryLiquidationTargetsResponse)(nil), "umee.leverage.v1.QueryLiquidationTargetsResponse")
	proto.RegisterType((*QueryBadDebts)(nil), "umee.leverage.v1.QueryBadDebts")
	proto.RegisterType((*QueryBadDebtsResponse)(nil), "umee.leverage.v1.QueryBadDebtsResponse")
	proto.RegisterType((*QueryMaxWithdraw)(nil), "umee.leverage.v1.QueryMaxWithdraw")
	proto.RegisterType((*QueryMaxWithdrawResponse)(nil), "umee.leverage.v1.QueryMaxWithdrawResponse")
	proto.RegisterType((*QueryMaxBorrow)(nil), "umee.leverage.v1.QueryMaxBorrow")
	proto.RegisterType((*QueryMaxBorrowResponse)(nil), "umee.leverage.v1.QueryMaxBorrowResponse")
	proto.RegisterType((*QueryInspect)(nil), "umee.leverage.v1.QueryInspect")
	proto.RegisterType((*QueryInspectAccount)(nil), "umee.leverage.v1.QueryInspectAccount")
	proto.RegisterType((*QueryInspectResponse)(nil), "umee.leverage.v1.QueryInspectResponse")
	proto.RegisterType((*QueryInspectAccountResponse)(nil), "umee.leverage.v1.QueryInspectAccountResponse")
	proto.RegisterType((*InspectAccount)(nil), "umee.leverage.v1.InspectAccount")
	proto.RegisterType((*RiskInfo)(nil), "umee.leverage.v1.RiskInfo")
	proto.RegisterType((*DecBalances)(nil), "umee.leverage.v1.DecBalances")
}

func init() { proto.RegisterFile("umee/leverage/v1/query.proto", fileDescriptor_1e8137dcabb0ccc7) }

var fileDescriptor_1e8137dcabb0ccc7 = []byte{
	// 1984 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x99, 0xcf, 0x6f, 0x1b, 0xc7,
	0x15, 0xc7, 0xb5, 0x92, 0x45, 0x51, 0x8f, 0xa2, 0x24, 0x8f, 0x65, 0x7b, 0x4d, 0x4b, 0x24, 0xbd,
	0xb6, 0x6c, 0xc5, 0x89, 0x48, 0x5b, 0x06, 0x8c, 0xa6, 0xbf, 0x4d, 0xab, 0x45, 0x1d, 0x38, 0x81,
	0xbc, 0x8e, 0x13, 0x38, 0x69, 0x43, 0x0c, 0x97, 0x63, 0x6a, 0xa1, 0xe5, 0x2e, 0xbd, 0xb3, 0x94,
	0xc5, 0x02, 0xb9, 0x04, 0xe8, 0xad, 0x2d, 0x1a, 0x14, 0x3d, 0xf4, 0xd8, 0x6b, 0x6f, 0xfd, 0x2b,
	0xaa, 0x63, 0x80, 0x5e, 0x8a, 0x16, 0x55, 0x5b, 0xbb, 0xe8, 0x21, 0x97, 0xfe, 0x03, 0x3d, 0x14,
	0xf3, 0x93, 0x4b, 0x2e, 0x29, 0x51, 0x8b, 0xea, 0x24, 0xce, 0xce, 0x7b, 0x9f, 0xf7, 0x9d, 0x37,
	0xbf, 0x47, 0xb0, 0xda, 0x6d, 0x13, 0x52, 0xf5, 0xc8, 0x3e, 0x09, 0x71, 0x8b, 0x54, 0xf7, 0xef,
	0x56, 0x5f, 0x76, 0x49, 0xd8, 0xab, 0x74, 0xc2, 0x20, 0x0a, 0xd0, 0x32, 0xab, 0xad, 0xa8, 0xda,
	0xca, 0xfe, 0xdd, 0xc2, 0x6a, 0x2b, 0x08, 0x5a, 0x1e, 0xa9, 0xe2, 0x8e, 0x5b, 0xc5, 0xbe, 0x1f,
	0x44, 0x38, 0x72, 0x03, 0x9f, 0x0a, 0xfb, 0x42, 0x31, 0x41, 0x6b, 0x11, 0x9f, 0x50, 0x57, 0xd5,
	0x97, 0x12, 0xf5, 0x9a, 0x2d, 0x0c, 0x56, 0x5a, 0x41, 0x2b, 0xe0, 0x3f, 0xab, 0xec, 0x97, 0xc2,
	0x3a, 0x01, 0x6d, 0x07, 0xb4, 0xda, 0xc0, 0x94, 0x39, 0x35, 0x48, 0x84, 0xef, 0x56, 0x9d, 0xc0,
	0xf5, 0x45, 0xbd, 0x95, 0x87, 0xdc, 0x13, 0xa6, 0x7a, 0x07, 0x87, 0xb8, 0x4d, 0xad, 0xf7, 0xe1,
	0x42, 0xac, 0x68, 0x13, 0xda, 0x09, 0x7c, 0x4a, 0xd0, 0x7d, 0xc8, 0x74, 0xf8, 0x17, 0xd3, 0x28,
	0x1b, 0x1b, 0xb9, 0x2d, 0xb3, 0x32, 0xdc, 0xba, 0x8a, 0xf0, 0xa8, 0x9d, 0x3b, 0x3c, 0x2a, 0x4d,
	0xd9, 0xd2, 0xda, 0xba, 0x0f, 0x17, 0x39, 0xce, 0x26, 0x2d, 0x97, 0x46, 0x24, 0x24, 0xcd, 0x0f,
	0x83, 0x3d, 0xe2, 0x53, 0xb4, 0x06, 0xc0, 0x14, 0xd5, 0x9b, 0xc4, 0x0f, 0xda, 0x1c, 0x3a, 0x6f,
	0xcf, 0xb3, 0x2f, 0xdb, 0xec, 0x83, 0xf5, 0x09, 0xac, 0x8d, 0xf4, 0xd3, 0x82, 0xde, 0x85, 0x6c,
	0xc8, 0xeb, 0xc2, 0x9e, 0x69, 0x94, 0x67, 0x36, 0x72, 0x5b, 0x97, 0x93, 0x92, 0xb8, 0x8f, 0x54,
	0xa4, 0xcd, 0x2d, 0x0b, 0xca, 0x23, 0xd9, 0x1f, 0xbb, 0xd1, 0xee, 0xfb, 0x38, 0xdc, 0x23, 0x11,
	0xb5, 0x5c, 0xd8, 0x38, 0xc9, 0x46, 0x4b, 0xf9, 0x0e, 0xcc, 0xb5, 0xc5, 0x27, 0xa9, 0x64, 0x6d,
	0x8c, 0x12, 0xe1, 0x28, 0xf5, 0x28, 0x1f, 0xeb, 0x97, 0x06, 0xe4, 0x62, 0xd5, 0xe8, 0x1e, 0xcc,
	0x46, 0xac, 0x28, 0x33, 0x7d, 0x42, 0xb3, 0x84, 0x2d, 0x7a, 0x0f, 0x32, 0x82, 0x67, 0x4e, 0x73,
	0xaf, 0x77, 0x92, 0x5e, 0xbc, 0x3d, 0x22, 0xc6, 0xd3, 0x6e, 0xbb, 0x8d, 0x59, 0xe3, 0x44, 0x0b,
	0x54, 0x9f, 0x09, 0x82, 0x75, 0x1b, 0x10, 0xb7, 0x7d, 0xda, 0x21, 0x8e, 0x8b, 0xbd, 0x07, 0x94,
	0x92, 0x88, 0xa2, 0x15, 0x98, 0x8d, 0xf7, 0x95, 0x28, 0x58, 0x3f, 0x86, 0x42, 0xd2, 0x56, 0x67,
	0xe6, 0xbb, 0x30, 0xdb, 0xc1, 0x6e, 0xa8, 0xf2, 0x62, 0x25, 0x45, 0xc5, 0xfd, 0x76, 0xb0, 0x1b,
	0xaa, 0x56, 0x71, 0x37, 0xad, 0x64, 0x40, 0xf5, 0x18, 0x25, 0xff, 0x5d, 0x90, 0x52, 0x46, 0x36,
	0x11, 0x5d, 0x83, 0x05, 0xda, 0x6b, 0x37, 0x02, 0x6f, 0x60, 0xc4, 0xe5, 0xc4, 0x37, 0x3e, 0xe6,
	0x50, 0x01, 0xb2, 0xe4, 0xa0, 0x13, 0xf8, 0xc4, 0x17, 0x59, 0xcc, 0xdb, 0xba, 0x8c, 0x9e, 0xc0,
	0x42, 0x10, 0x62, 0xc7, 0x23, 0xf5, 0x4e, 0xe8, 0x3a, 0xc4, 0x9c, 0x61, 0xee, 0xb5, 0xca, 0xe1,
	0x51, 0xc9, 0xf8, 0xcb, 0x51, 0xe9, 0x66, 0xcb, 0x8d, 0x76, 0xbb, 0x8d, 0x8a, 0x13, 0xb4, 0xab,
	0x72, 0xba, 0x89, 0x3f, 0x9b, 0xb4, 0xb9, 0x57, 0x8d, 0x7a, 0x1d, 0x42, 0x2b, 0xdb, 0xc4, 0xb1,
	0x73, 0x82, 0xb1, 0xc3, 0x10, 0xe8, 0x00, 0x56, 0xba, 0xbc, 0x27, 0xeb, 0xe4, 0xc0, 0xd9, 0xc5,
	0x7e, 0x8b, 0xd4, 0x43, 0x1c, 0x11, 0xf3, 0x1c, 0x47, 0xff, 0x90, 0xe5, 0x61, 0x72, 0xf4, 0xd7,
	0x47, 0xa5, 0x95, 0x6e, 0x94, 0xa4, 0xd9, 0x48, 0xc4, 0xf8, 0x81, 0xfc, 0x68, 0xe3, 0x88, 0xa0,
	0x4f, 0x01, 0x68, 0xb7, 0xd3, 0xf1, 0x7a, 0xf5, 0x07, 0x3b, 0xcf, 0xcd, 0x59, 0x1e, 0xef, 0xdb,
	0xa7, 0x8e, 0xa7, 0x18, 0xb8, 0xd3, 0xb3, 0xe7, 0xc5, 0xef, 0x07, 0x3b, 0xcf, 0x19, 0xbc, 0x11,
	0x84, 0x61, 0xf0, 0x8a, 0xc3, 0x33, 0x69, 0xe1, 0x92, 0xc1, 0xe1, 0xe2, 0x37, 0x83, 0xbf, 0x07,
	0x59, 0x1e, 0xc9, 0x25, 0x4d, 0x73, 0x4e, 0x77, 0xc1, 0xa4, 0xe8, 0x47, 0x7e, 0x64, 0x6b, 0x7f,
	0xc6, 0x0a, 0x09, 0x25, 0xe1, 0x3e, 0x69, 0x9a, 0xd9, 0x74, 0x2c, 0xe5, 0x8f, 0x3e, 0x00, 0x70,
	0x02, 0xcf, 0xc3, 0x11, 0x09, 0xb1, 0x67, 0xce, 0xa7, 0xa2, 0xc5, 0x08, 0x4c, 0x9b, 0x68, 0x34,
	0x69, 0x9a, 0x90, 0x4e, 0x9b, 0xf2, 0x47, 0x8f, 0x61, 0xde, 0x73, 0x5f, 0x76, 0xdd, 0xa6, 0x1b,
	0xf5, 0xcc, 0x5c, 0x2a, 0x58, 0x1f, 0x80, 0x9e, 0xc1, 0x62, 0x1b, 0x1f, 0xb8, 0xed, 0x6e, 0xbb,
	0x2e, 0x22, 0x98, 0x0b, 0xa9, 0x90, 0x79, 0x49, 0xa9, 0x71, 0x08, 0xfa, 0x09, 0x20, 0x85, 0x8d,
	0x25, 0x32, 0x9f, 0x0a, 0x7d, 0x5e, 0x92, 0x1e, 0xf6, 0xf3, 0xf9, 0x29, 0x9c, 0x6f, 0xbb, 0x3e,
	0xc7, 0xf7, 0x73, 0xb1, 0x98, 0x8a, 0xbe, 0x2c, 0x41, 0x8f, 0x75, 0x4a, 0x9a, 0x90, 0x97, 0x13,
	0x59, 0xcc, 0x02, 0x73, 0x89, 0x83, 0xbf, 0x77, 0x3a, 0xf0, 0xd7, 0x47, 0xa5, 0xbc, 0x9c, 0xc1,
	0x02, 0x63, 0x2f, 0x08, 0xea, 0x53, 0x5e, 0x42, 0xcf, 0x61, 0x19, 0xef, 0x63, 0xd7, 0xc3, 0x0d,
	0x8f, 0xa8, 0xd4, 0x2f, 0xa7, 0x6a, 0xc1, 0x92, 0xe6, 0xf4, 0x93, 0xdf, 0x47, 0xbf, 0x72, 0xa3,
	0xdd, 0x66, 0x88, 0x5f, 0x99, 0xe7, 0xd3, 0x25, 0x5f, 0x93, 0x3e, 0x96, 0x20, 0xd4, 0x82, 0xcb,
	0x7d, 0x7c, 0xbf, 0x77, 0xdd, 0x9f, 0x12, 0x13, 0xa5, 0x8a, 0x71, 0x49, 0xe3, 0x1e, 0xc6, 0x69,
	0xa8, 0x01, 0x17, 0xe5, 0x22, 0xbd, 0xeb, 0xd2, 0x28, 0x08, 0x5d, 0x47, 0xae, 0xd6, 0x17, 0x52,
	0xad, 0xd6, 0x17, 0x04, 0xec, 0x47, 0x92, 0x25, 0x56, 0xed, 0x4b, 0x90, 0x21, 0x61, 0x18, 0x84,
	0xd4, 0x5c, 0xe1, 0x3b, 0x88, 0x2c, 0x59, 0x77, 0x60, 0x85, 0xef, 0x3e, 0x0f, 0x1c, 0x27, 0xe8,
	0xfa, 0x51, 0x0d, 0x7b, 0xd8, 0x77, 0x08, 0x45, 0x26, 0xcc, 0xe1, 0x66, 0x33, 0x24, 0x94, 0xca,
	0x2d, 0x47, 0x15, 0xad, 0xbf, 0x4d, 0xc3, 0xea, 0x28, 0x17, 0xbd, 0x65, 0xb5, 0x62, 0x8b, 0x9d,
	0xd8, 0x40, 0xaf, 0x54, 0x84, 0xd0, 0x0a, 0x3b, 0x28, 0x55, 0xe4, 0x61, 0xae, 0xf2, 0x30, 0x70,
	0xfd, 0xda, 0x1d, 0x96, 0xc3, 0xdf, 0xff, 0xbd, 0xb4, 0x31, 0x41, 0xe3, 0x98, 0x03, 0x8d, 0xad,
	0x84, 0x7b, 0x03, 0xab, 0xd7, 0xf4, 0xff, 0x3f, 0x54, 0x7c, 0x69, 0x6b, 0xc5, 0x96, 0xb6, 0x99,
	0x33, 0x68, 0x95, 0x82, 0x5b, 0x55, 0x79, 0x92, 0x95, 0xe9, 0x55, 0xa7, 0x87, 0xf1, 0x1d, 0xf2,
	0x45, 0x06, 0xae, 0x8e, 0xf0, 0xd0, 0xfd, 0xf1, 0x0c, 0x16, 0x55, 0xca, 0xea, 0xfb, 0xd8, 0xeb,
	0x12, 0x01, 0x38, 0xd5, 0xf0, 0x65, 0xe3, 0x2a, 0xaf, 0x28, 0x1f, 0x31, 0x08, 0x9b, 0xd8, 0xfd,
	0xf4, 0x48, 0xf0, 0x74, 0x2a, 0xf0, 0x52, 0x9f, 0x23, 0xd0, 0xcf, 0x60, 0x51, 0xa5, 0x43, 0x82,
	0x67, 0xd2, 0x29, 0x56, 0x14, 0x81, 0x7d, 0x02, 0x0b, 0x72, 0x7b, 0xf6, 0xdc, 0xb6, 0x1b, 0xc9,
	0x13, 0xcb, 0xa9, 0x0f, 0x43, 0x82, 0xf1, 0x98, 0x21, 0x90, 0x03, 0x17, 0xc5, 0xc2, 0xcc, 0xaf,
	0x44, 0xf5, 0x68, 0x37, 0x24, 0x74, 0x37, 0xf0, 0x9a, 0xf2, 0x74, 0x72, 0x5a, 0xf6, 0x4a, 0x0c,
	0xf6, 0xa1, 0x62, 0xa1, 0xcf, 0xe0, 0x02, 0xed, 0x04, 0x51, 0x7d, 0xa8, 0x17, 0x33, 0xa9, 0x72,
	0x72, 0x9e, 0xa1, 0x9e, 0x0e, 0xf4, 0x64, 0x03, 0x2e, 0x72, 0x7e, 0xa2, 0x3b, 0xe7, 0x52, 0x45,
	0xe0, 0x62, 0x1f, 0x0e, 0x75, 0xa9, 0x6a, 0xc3, 0x50, 0xbf, 0x66, 0xd3, 0xb7, 0xa1, 0x16, 0xef,
	0x5b, 0xeb, 0x0a, 0x5c, 0xe6, 0x73, 0xe0, 0x71, 0x2c, 0x81, 0x38, 0x6c, 0xb1, 0x8b, 0xca, 0xb7,
	0xa0, 0x34, 0xa6, 0x4a, 0x4f, 0x11, 0x13, 0xe6, 0x22, 0xf1, 0x89, 0xaf, 0x58, 0xf3, 0xb6, 0x2a,
	0x5a, 0x4b, 0x90, 0xe7, 0xce, 0x35, 0xdc, 0xdc, 0x26, 0x8d, 0x88, 0x5a, 0xb6, 0xbc, 0x19, 0xaa,
	0x0f, 0xb1, 0x9b, 0xdd, 0x00, 0x83, 0xad, 0x0f, 0x89, 0x6b, 0x83, 0x74, 0x52, 0x57, 0x29, 0x15,
	0xa4, 0x06, 0xcb, 0xf2, 0x0a, 0x70, 0xa0, 0x77, 0x9f, 0xb1, 0xf3, 0xbd, 0x7f, 0x8f, 0x98, 0x8e,
	0xdf, 0x23, 0xfe, 0x6d, 0x80, 0x39, 0x0c, 0xd1, 0xda, 0x08, 0xcc, 0x89, 0x4d, 0x99, 0x9e, 0xc5,
	0x8a, 0xac, 0xd8, 0xc8, 0x81, 0x4c, 0x24, 0xa2, 0x9c, 0xc1, 0x62, 0x2c, 0xd1, 0xd6, 0xf7, 0x61,
	0x51, 0xb5, 0x53, 0x9e, 0x03, 0x4e, 0x9b, 0xaa, 0xcf, 0xe1, 0xd2, 0x20, 0x41, 0xe7, 0xa9, 0xdf,
	0x00, 0xe3, 0xec, 0x1a, 0xf0, 0x73, 0x03, 0x16, 0x78, 0xfc, 0x47, 0x3e, 0xed, 0x10, 0x27, 0x62,
	0x7b, 0xb3, 0xb8, 0xcf, 0x49, 0xf9, 0xb2, 0xc4, 0x2e, 0x76, 0x7a, 0xcb, 0x61, 0x0d, 0x30, 0x62,
	0xa7, 0xe3, 0xe2, 0xc0, 0xde, 0x37, 0xc3, 0x6b, 0xe3, 0xdb, 0xd5, 0x25, 0xc8, 0x34, 0xd9, 0xc5,
	0x29, 0xe4, 0xab, 0x9c, 0x61, 0xcb, 0x12, 0x5a, 0x86, 0x19, 0x2f, 0xda, 0xe7, 0xcb, 0x93, 0x61,
	0xb3, 0x9f, 0x7a, 0xbf, 0x91, 0x6a, 0xe4, 0x26, 0x72, 0xcc, 0x7e, 0x73, 0x20, 0x8f, 0x0c, 0xd2,
	0x41, 0x27, 0x6f, 0x1b, 0xe4, 0x8d, 0x87, 0xe8, 0x9b, 0x73, 0x39, 0x39, 0x05, 0x06, 0xc3, 0xc8,
	0x99, 0xd0, 0x77, 0x64, 0x8d, 0x7e, 0x81, 0x5d, 0xaf, 0x1b, 0x12, 0x31, 0x8a, 0xe6, 0x6d, 0x5d,
	0xb6, 0xb0, 0xdc, 0xe8, 0x06, 0x19, 0x5a, 0x40, 0x4d, 0xe7, 0x2b, 0x94, 0x8f, 0x10, 0x93, 0xc6,
	0xd7, 0x7e, 0xd6, 0x1f, 0x0c, 0x58, 0x9c, 0x34, 0x13, 0xe8, 0x3e, 0x64, 0xb1, 0x8f, 0xbd, 0x1e,
	0x75, 0xa9, 0x7c, 0xbf, 0x28, 0x24, 0x03, 0xda, 0x2e, 0xdd, 0x7b, 0xe4, 0xbf, 0x08, 0x6c, 0x6d,
	0x8b, 0xde, 0x85, 0x6c, 0x27, 0xa0, 0x2e, 0x5b, 0x89, 0x78, 0xd7, 0x8d, 0x7c, 0x7a, 0xd9, 0x26,
	0x8e, 0x3e, 0x5a, 0x69, 0x73, 0x84, 0xe0, 0x9c, 0xeb, 0xbf, 0x08, 0xc4, 0xde, 0x65, 0xf3, 0xdf,
	0xd6, 0x67, 0x90, 0x55, 0x41, 0x58, 0xfa, 0xd4, 0xc2, 0xc8, 0xd5, 0x1a, 0xb6, 0x2e, 0xa3, 0x32,
	0xe4, 0x62, 0x6b, 0xa0, 0x1c, 0x52, 0xf1, 0x4f, 0x6c, 0xbe, 0x7c, 0xa4, 0xf7, 0x5b, 0xc3, 0x16,
	0x05, 0xeb, 0x3f, 0x06, 0xe4, 0x62, 0x6a, 0xd0, 0xcb, 0x81, 0xb1, 0x27, 0x7a, 0x7a, 0x75, 0xe4,
	0x4c, 0xd9, 0x26, 0x0e, 0x9f, 0x2c, 0xf7, 0xe4, 0x64, 0x79, 0x7b, 0xb2, 0x05, 0x3e, 0x79, 0xfa,
	0x6a, 0x0f, 0x4c, 0x85, 0x33, 0x0a, 0xa8, 0x43, 0x6c, 0xfd, 0x75, 0x11, 0x66, 0xf9, 0x48, 0x43,
	0x1d, 0xc8, 0x88, 0x07, 0x42, 0xb4, 0x36, 0xe6, 0x69, 0x4a, 0x54, 0x17, 0xd6, 0x8f, 0xad, 0x56,
	0x63, 0xd4, 0x2a, 0x7f, 0xf1, 0xa7, 0x7f, 0xfd, 0x7a, 0xba, 0x80, 0xcc, 0x6a, 0xe2, 0x59, 0x54,
	0x3c, 0x3d, 0xa2, 0xdf, 0x1a, 0xb0, 0x9c, 0x78, 0x76, 0xbc, 0x35, 0x86, 0x3e, 0x6c, 0x58, 0xa8,
	0x4e, 0x68, 0xa8, 0x05, 0xbd, 0xcd, 0x05, 0xad, 0xa3, 0xeb, 0x49, 0x41, 0xa1, 0xf6, 0xa9, 0x8b,
	0xa5, 0x0b, 0xfd, 0xd1, 0x80, 0xab, 0xc7, 0x3c, 0x2d, 0xa2, 0xad, 0x09, 0xa3, 0xc7, 0x7c, 0x0a,
	0xdf, 0x3c, 0xbd, 0x8f, 0x16, 0xff, 0x0d, 0x2e, 0x7e, 0x0b, 0xdd, 0x99, 0x40, 0x3c, 0xbf, 0x21,
	0xd6, 0xe5, 0xeb, 0x25, 0xfa, 0x85, 0x01, 0xf9, 0xc1, 0x87, 0xc2, 0x1b, 0x63, 0x74, 0x0c, 0x58,
	0x15, 0xde, 0x99, 0xc4, 0x4a, 0xeb, 0xdb, 0xe0, 0xfa, 0x2c, 0x54, 0x4e, 0xea, 0xa3, 0xc2, 0xa1,
	0x8e, 0x45, 0x74, 0xa6, 0x67, 0xf0, 0xb9, 0xf0, 0xc6, 0x24, 0x4f, 0xa1, 0x85, 0x53, 0x3d, 0x98,
	0x1e, 0xa7, 0x47, 0x24, 0xa6, 0x4e, 0x65, 0xf4, 0xdf, 0x18, 0xb0, 0x34, 0x7c, 0x27, 0xbc, 0x39,
	0x26, 0xd6, 0x90, 0x5d, 0xa1, 0x32, 0x99, 0x9d, 0x56, 0x75, 0x9b, 0xab, 0xba, 0x81, 0xac, 0xa4,
	0x2a, 0x2c, 0x5c, 0xea, 0x0d, 0xa5, 0xe1, 0x4b, 0x03, 0x16, 0x87, 0x6e, 0x46, 0xeb, 0xc7, 0x87,
	0x53, 0x99, 0xda, 0x9c, 0xc8, 0x4c, 0x8b, 0x7a, 0x8b, 0x8b, 0xba, 0x8e, 0xae, 0x8d, 0x17, 0xa5,
	0x72, 0xf5, 0x3b, 0x03, 0x50, 0xf2, 0x70, 0x89, 0xde, 0x1a, 0x13, 0x30, 0x69, 0x5a, 0xb8, 0x3b,
	0xb1, 0xa9, 0xd6, 0xb7, 0xc9, 0xf5, 0xdd, 0x42, 0xeb, 0x49, 0x7d, 0x03, 0x37, 0x12, 0x29, 0xa6,
	0x07, 0x59, 0x75, 0x62, 0x45, 0xa5, 0x31, 0xd1, 0x94, 0x41, 0xe1, 0xd6, 0x09, 0x06, 0x5a, 0xc4,
	0x75, 0x2e, 0x62, 0x0d, 0x5d, 0x4d, 0x8a, 0x68, 0xe0, 0x66, 0xbd, 0xc9, 0xc3, 0xfd, 0xcc, 0x80,
	0x5c, 0xfc, 0x64, 0x6b, 0x8d, 0x1d, 0xb2, 0xda, 0xa6, 0x70, 0xfb, 0x64, 0x1b, 0x2d, 0xe2, 0x26,
	0x17, 0x51, 0x46, 0xc5, 0x51, 0x83, 0xfa, 0x40, 0x3f, 0x0c, 0xa1, 0xcf, 0x61, 0xbe, 0x7f, 0x66,
	0x2c, 0x8f, 0x0f, 0x20, 0x2c, 0x0a, 0x1b, 0x27, 0x59, 0x68, 0x01, 0x37, 0xb8, 0x80, 0x22, 0x5a,
	0x1d, 0x2d, 0x40, 0xec, 0x2a, 0x28, 0x82, 0x39, 0x75, 0xe0, 0x2b, 0x8e, 0x41, 0xcb, 0xfa, 0xc2,
	0xcd, 0xe3, 0xeb, 0x75, 0xe0, 0x6b, 0x3c, 0xf0, 0x55, 0x74, 0x25, 0x19, 0xd8, 0x95, 0xa1, 0xbe,
	0x4c, 0x9e, 0x67, 0xd6, 0x8f, 0xa7, 0x4b, 0xb3, 0xb1, 0xf3, 0x65, 0xf4, 0xe1, 0xeb, 0xb8, 0xf9,
	0x22, 0xb5, 0x6c, 0xca, 0x79, 0x53, 0xfb, 0xe0, 0xf0, 0x9f, 0xc5, 0xa9, 0xc3, 0xd7, 0x45, 0xe3,
	0xab, 0xd7, 0x45, 0xe3, 0x1f, 0xaf, 0x8b, 0xc6, 0xaf, 0xde, 0x14, 0xa7, 0xbe, 0x7a, 0x53, 0x9c,
	0xfa, 0xf3, 0x9b, 0xe2, 0xd4, 0x27, 0x77, 0x62, 0x5b, 0x36, 0x43, 0x6d, 0xfa, 0x24, 0x7a, 0x15,
	0x84, 0x7b, 0x82, 0xbb, 0x7f, 0xbf, 0x7a, 0xd0, 0x87, 0xf3, 0x0d, 0xbc, 0x91, 0xe1, 0xff, 0x11,
	0xbc, 0xf7, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xab, 0x99, 0xab, 0x86, 0xd8, 0x1c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// Params queries the parameters of the x/leverage module.
	Params(ctx context.Context, in *QueryParams, opts ...grpc.CallOption) (*QueryParamsResponse, error)
	// RegisteredTokens queries for all the registered tokens.
	RegisteredTokens(ctx context.Context, in *QueryRegisteredTokens, opts ...grpc.CallOption) (*QueryRegisteredTokensResponse, error)
	// RegisteredTokensWithMarkets queries for all the registered tokens and their market summaries.
	RegisteredTokensWithMarkets(ctx context.Context, in *QueryRegisteredTokensWithMarkets, opts ...grpc.CallOption) (*QueryRegisteredTokensWithMarketsResponse, error)
	// SpecialAssets queries for all special asset pairs.
	SpecialAssets(ctx context.Context, in *QuerySpecialAssets, opts ...grpc.CallOption) (*QuerySpecialAssetsResponse, error)
	// MarketSummary queries a base asset's current borrowing and supplying conditions.
	MarketSummary(ctx context.Context, in *QueryMarketSummary, opts ...grpc.CallOption) (*QueryMarketSummaryResponse, error)
	// AccountBalances queries an account's current supply, collateral, and borrow positions.
	AccountBalances(ctx context.Context, in *QueryAccountBalances, opts ...grpc.CallOption) (*QueryAccountBalancesResponse, error)
	// AccountSummary queries USD values representing an account's total positions and borrowing limits. It requires oracle prices to return successfully.
	AccountSummary(ctx context.Context, in *QueryAccountSummary, opts ...grpc.CallOption) (*QueryAccountSummaryResponse, error)
	// LiquidationTargets queries a list of all borrower account addresses eligible for liquidation.
	LiquidationTargets(ctx context.Context, in *QueryLiquidationTargets, opts ...grpc.CallOption) (*QueryLiquidationTargetsResponse, error)
	// BadDebts queries a list of borrow positions that have been marked for bad debt repayment.
	BadDebts(ctx context.Context, in *QueryBadDebts, opts ...grpc.CallOption) (*QueryBadDebtsResponse, error)
	// MaxWithdraw queries the maximum amount of a given token an address can withdraw.
	MaxWithdraw(ctx context.Context, in *QueryMaxWithdraw, opts ...grpc.CallOption) (*QueryMaxWithdrawResponse, error)
	// MaxBorrow queries the maximum amount of a given token an address can borrow.
	MaxBorrow(ctx context.Context, in *QueryMaxBorrow, opts ...grpc.CallOption) (*QueryMaxBorrowResponse, error)
	// Inspect is the customizable inspector query. It returns a list of all borrowers,
	// starting from the highest borrowed value, filtered by any combination of: minimum
	// borrowed value (optionally of a specified token), minimum collateral value, minimum
	// progress toward liquidation threshold, and minimum LTV. Each account is displayed
	// with its address and borrowed/liquidation/collateral USD values, as well as its
	// actual token positions in human-readable symbol denoms instead of uTokens or ibc denoms.
	Inspect(ctx context.Context, in *QueryInspect, opts ...grpc.CallOption) (*QueryInspectResponse, error)
	// InspectAccount runs the inspect query on a single address
	InspectAccount(ctx context.Context, in *QueryInspectAccount, opts ...grpc.CallOption) (*QueryInspectAccountResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Params(ctx context.Context, in *QueryParams, opts ...grpc.CallOption) (*QueryParamsResponse, error) {
	out := new(QueryParamsResponse)
	err := c.cc.Invoke(ctx, "/umee.leverage.v1.Query/Params", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) RegisteredTokens(ctx context.Context, in *QueryRegisteredTokens, opts ...grpc.CallOption) (*QueryRegisteredTokensResponse, error) {
	out := new(QueryRegisteredTokensResponse)
	err := c.cc.Invoke(ctx, "/umee.leverage.v1.Query/RegisteredTokens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) RegisteredTokensWithMarkets(ctx context.Context, in *QueryRegisteredTokensWithMarkets, opts ...grpc.CallOption) (*QueryRegisteredTokensWithMarketsResponse, error) {
	out := new(QueryRegisteredTokensWithMarketsResponse)
	err := c.cc.Invoke(ctx, "/umee.leverage.v1.Query/RegisteredTokensWithMarkets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) SpecialAssets(ctx context.Context, in *QuerySpecialAssets, opts ...grpc.CallOption) (*QuerySpecialAssetsResponse, error) {
	out := new(QuerySpecialAssetsResponse)
	err := c.cc.Invoke(ctx, "/umee.leverage.v1.Query/SpecialAssets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) MarketSummary(ctx context.Context, in *QueryMarketSummary, opts ...grpc.CallOption) (*QueryMarketSummaryResponse, error) {
	out := new(QueryMarketSummaryResponse)
	err := c.cc.Invoke(ctx, "/umee.leverage.v1.Query/MarketSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AccountBalances(ctx context.Context, in *QueryAccountBalances, opts ...grpc.CallOption) (*QueryAccountBalancesResponse, error) {
	out := new(QueryAccountBalancesResponse)
	err := c.cc.Invoke(ctx, "/umee.leverage.v1.Query/AccountBalances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AccountSummary(ctx context.Context, in *QueryAccountSummary, opts ...grpc.CallOption) (*QueryAccountSummaryResponse, error) {
	out := new(QueryAccountSummaryResponse)
	err := c.cc.Invoke(ctx, "/umee.leverage.v1.Query/AccountSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) LiquidationTargets(ctx context.Context, in *QueryLiquidationTargets, opts ...grpc.CallOption) (*QueryLiquidationTargetsResponse, error) {
	out := new(QueryLiquidationTargetsResponse)
	err := c.cc.Invoke(ctx, "/umee.leverage.v1.Query/LiquidationTargets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) BadDebts(ctx context.Context, in *QueryBadDebts, opts ...grpc.CallOption) (*QueryBadDebtsResponse, error) {
	out := new(QueryBadDebtsResponse)
	err := c.cc.Invoke(ctx, "/umee.leverage.v1.Query/BadDebts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) MaxWithdraw(ctx context.Context, in *QueryMaxWithdraw, opts ...grpc.CallOption) (*QueryMaxWithdrawResponse, error) {
	out := new(QueryMaxWithdrawResponse)
	err := c.cc.Invoke(ctx, "/umee.leverage.v1.Query/MaxWithdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) MaxBorrow(ctx context.Context, in *QueryMaxBorrow, opts ...grpc.CallOption) (*QueryMaxBorrowResponse, error) {
	out := new(QueryMaxBorrowResponse)
	err := c.cc.Invoke(ctx, "/umee.leverage.v1.Query/MaxBorrow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Inspect(ctx context.Context, in *QueryInspect, opts ...grpc.CallOption) (*QueryInspectResponse, error) {
	out := new(QueryInspectResponse)
	err := c.cc.Invoke(ctx, "/umee.leverage.v1.Query/Inspect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) InspectAccount(ctx context.Context, in *QueryInspectAccount, opts ...grpc.CallOption) (*QueryInspectAccountResponse, error) {
	out := new(QueryInspectAccountResponse)
	err := c.cc.Invoke(ctx, "/umee.leverage.v1.Query/InspectAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// Params queries the parameters of the x/leverage module.
	Params(context.Context, *QueryParams) (*QueryParamsResponse, error)
	// RegisteredTokens queries for all the registered tokens.
	RegisteredTokens(context.Context, *QueryRegisteredTokens) (*QueryRegisteredTokensResponse, error)
	// RegisteredTokensWithMarkets queries for all the registered tokens and their market summaries.
	RegisteredTokensWithMarkets(context.Context, *QueryRegisteredTokensWithMarkets) (*QueryRegisteredTokensWithMarketsResponse, error)
	// SpecialAssets queries for all special asset pairs.
	SpecialAssets(context.Context, *QuerySpecialAssets) (*QuerySpecialAssetsResponse, error)
	// MarketSummary queries a base asset's current borrowing and supplying conditions.
	MarketSummary(context.Context, *QueryMarketSummary) (*QueryMarketSummaryResponse, error)
	// AccountBalances queries an account's current supply, collateral, and borrow positions.
	AccountBalances(context.Context, *QueryAccountBalances) (*QueryAccountBalancesResponse, error)
	// AccountSummary queries USD values representing an account's total positions and borrowing limits. It requires oracle prices to return successfully.
	AccountSummary(context.Context, *QueryAccountSummary) (*QueryAccountSummaryResponse, error)
	// LiquidationTargets queries a list of all borrower account addresses eligible for liquidation.
	LiquidationTargets(context.Context, *QueryLiquidationTargets) (*QueryLiquidationTargetsResponse, error)
	// BadDebts queries a list of borrow positions that have been marked for bad debt repayment.
	BadDebts(context.Context, *QueryBadDebts) (*QueryBadDebtsResponse, error)
	// MaxWithdraw queries the maximum amount of a given token an address can withdraw.
	MaxWithdraw(context.Context, *QueryMaxWithdraw) (*QueryMaxWithdrawResponse, error)
	// MaxBorrow queries the maximum amount of a given token an address can borrow.
	MaxBorrow(context.Context, *QueryMaxBorrow) (*QueryMaxBorrowResponse, error)
	// Inspect is the customizable inspector query. It returns a list of all borrowers,
	// starting from the highest borrowed value, filtered by any combination of: minimum
	// borrowed value (optionally of a specified token), minimum collateral value, minimum
	// progress toward liquidation threshold, and minimum LTV. Each account is displayed
	// with its address and borrowed/liquidation/collateral USD values, as well as its
	// actual token positions in human-readable symbol denoms instead of uTokens or ibc denoms.
	Inspect(context.Context, *QueryInspect) (*QueryInspectResponse, error)
	// InspectAccount runs the inspect query on a single address
	InspectAccount(context.Context, *QueryInspectAccount) (*QueryInspectAccountResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Params(ctx context.Context, req *QueryParams) (*QueryParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}
func (*UnimplementedQueryServer) RegisteredTokens(ctx context.Context, req *QueryRegisteredTokens) (*QueryRegisteredTokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisteredTokens not implemented")
}
func (*UnimplementedQueryServer) RegisteredTokensWithMarkets(ctx context.Context, req *QueryRegisteredTokensWithMarkets) (*QueryRegisteredTokensWithMarketsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisteredTokensWithMarkets not implemented")
}
func (*UnimplementedQueryServer) SpecialAssets(ctx context.Context, req *QuerySpecialAssets) (*QuerySpecialAssetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpecialAssets not implemented")
}
func (*UnimplementedQueryServer) MarketSummary(ctx context.Context, req *QueryMarketSummary) (*QueryMarketSummaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketSummary not implemented")
}
func (*UnimplementedQueryServer) AccountBalances(ctx context.Context, req *QueryAccountBalances) (*QueryAccountBalancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountBalances not implemented")
}
func (*UnimplementedQueryServer) AccountSummary(ctx context.Context, req *QueryAccountSummary) (*QueryAccountSummaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountSummary not implemented")
}
func (*UnimplementedQueryServer) LiquidationTargets(ctx context.Context, req *QueryLiquidationTargets) (*QueryLiquidationTargetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LiquidationTargets not implemented")
}
func (*UnimplementedQueryServer) BadDebts(ctx context.Context, req *QueryBadDebts) (*QueryBadDebtsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BadDebts not implemented")
}
func (*UnimplementedQueryServer) MaxWithdraw(ctx context.Context, req *QueryMaxWithdraw) (*QueryMaxWithdrawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MaxWithdraw not implemented")
}
func (*UnimplementedQueryServer) MaxBorrow(ctx context.Context, req *QueryMaxBorrow) (*QueryMaxBorrowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MaxBorrow not implemented")
}
func (*UnimplementedQueryServer) Inspect(ctx context.Context, req *QueryInspect) (*QueryInspectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Inspect not implemented")
}
func (*UnimplementedQueryServer) InspectAccount(ctx context.Context, req *QueryInspectAccount) (*QueryInspectAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectAccount not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Params(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/umee.leverage.v1.Query/Params",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Params(ctx, req.(*QueryParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_RegisteredTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRegisteredTokens)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).RegisteredTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/umee.leverage.v1.Query/RegisteredTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).RegisteredTokens(ctx, req.(*QueryRegisteredTokens))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_RegisteredTokensWithMarkets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRegisteredTokensWithMarkets)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).RegisteredTokensWithMarkets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/umee.leverage.v1.Query/RegisteredTokensWithMarkets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).RegisteredTokensWithMarkets(ctx, req.(*QueryRegisteredTokensWithMarkets))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_SpecialAssets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySpecialAssets)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).SpecialAssets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/umee.leverage.v1.Query/SpecialAssets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).SpecialAssets(ctx, req.(*QuerySpecialAssets))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_MarketSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMarketSummary)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).MarketSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/umee.leverage.v1.Query/MarketSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).MarketSummary(ctx, req.(*QueryMarketSummary))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AccountBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAccountBalances)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AccountBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/umee.leverage.v1.Query/AccountBalances",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AccountBalances(ctx, req.(*QueryAccountBalances))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AccountSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAccountSummary)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AccountSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/umee.leverage.v1.Query/AccountSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AccountSummary(ctx, req.(*QueryAccountSummary))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_LiquidationTargets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryLiquidationTargets)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).LiquidationTargets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/umee.leverage.v1.Query/LiquidationTargets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).LiquidationTargets(ctx, req.(*QueryLiquidationTargets))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_BadDebts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryBadDebts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).BadDebts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/umee.leverage.v1.Query/BadDebts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).BadDebts(ctx, req.(*QueryBadDebts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_MaxWithdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMaxWithdraw)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).MaxWithdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/umee.leverage.v1.Query/MaxWithdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).MaxWithdraw(ctx, req.(*QueryMaxWithdraw))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_MaxBorrow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMaxBorrow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).MaxBorrow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/umee.leverage.v1.Query/MaxBorrow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).MaxBorrow(ctx, req.(*QueryMaxBorrow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Inspect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryInspect)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Inspect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/umee.leverage.v1.Query/Inspect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Inspect(ctx, req.(*QueryInspect))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_InspectAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryInspectAccount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).InspectAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/umee.leverage.v1.Query/InspectAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).InspectAccount(ctx, req.(*QueryInspectAccount))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "umee.leverage.v1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Params",
			Handler:    _Query_Params_Handler,
		},
		{
			MethodName: "RegisteredTokens",
			Handler:    _Query_RegisteredTokens_Handler,
		},
		{
			MethodName: "RegisteredTokensWithMarkets",
			Handler:    _Query_RegisteredTokensWithMarkets_Handler,
		},
		{
			MethodName: "SpecialAssets",
			Handler:    _Query_SpecialAssets_Handler,
		},
		{
			MethodName: "MarketSummary",
			Handler:    _Query_MarketSummary_Handler,
		},
		{
			MethodName: "AccountBalances",
			Handler:    _Query_AccountBalances_Handler,
		},
		{
			MethodName: "AccountSummary",
			Handler:    _Query_AccountSummary_Handler,
		},
		{
			MethodName: "LiquidationTargets",
			Handler:    _Query_LiquidationTargets_Handler,
		},
		{
			MethodName: "BadDebts",
			Handler:    _Query_BadDebts_Handler,
		},
		{
			MethodName: "MaxWithdraw",
			Handler:    _Query_MaxWithdraw_Handler,
		},
		{
			MethodName: "MaxBorrow",
			Handler:    _Query_MaxBorrow_Handler,
		},
		{
			MethodName: "Inspect",
			Handler:    _Query_Inspect_Handler,
		},
		{
			MethodName: "InspectAccount",
			Handler:    _Query_InspectAccount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "umee/leverage/v1/query.proto",
}

func (m *QueryParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryRegisteredTokens) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRegisteredTokens) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRegisteredTokens) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryRegisteredTokensResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRegisteredTokensResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRegisteredTokensResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Registry) > 0 {
		for iNdEx := len(m.Registry) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Registry[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryRegisteredTokensWithMarkets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRegisteredTokensWithMarkets) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRegisteredTokensWithMarkets) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryRegisteredTokensWithMarketsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRegisteredTokensWithMarketsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRegisteredTokensWithMarketsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Markets) > 0 {
		for iNdEx := len(m.Markets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Markets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TokenMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Market.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QuerySpecialAssets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpecialAssets) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySpecialAssets) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QuerySpecialAssetsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpecialAssetsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySpecialAssetsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pairs) > 0 {
		for iNdEx := len(m.Pairs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pairs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryMarketSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMarketSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMarketSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryMarketSummaryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMarketSummaryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMarketSummaryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Errors) > 0 {
		i -= len(m.Errors)
		copy(dAtA[i:], m.Errors)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Errors)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.OracleHistoricPrice != nil {
		{
			size := m.OracleHistoricPrice.Size()
			i -= size
			if _, err := m.OracleHistoricPrice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	{
		size := m.AvailableCollateralize.Size()
		i -= size
		if _, err := m.AvailableCollateralize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	{
		size := m.AvailableWithdraw.Size()
		i -= size
		if _, err := m.AvailableWithdraw.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	{
		size := m.AvailableBorrow.Size()
		i -= size
		if _, err := m.AvailableBorrow.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	{
		size := m.UTokenSupply.Size()
		i -= size
		if _, err := m.UTokenSupply.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size := m.MinimumLiquidity.Size()
		i -= size
		if _, err := m.MinimumLiquidity.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.MaximumCollateral.Size()
		i -= size
		if _, err := m.MaximumCollateral.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.MaximumBorrow.Size()
		i -= size
		if _, err := m.MaximumBorrow.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.Liquidity.Size()
		i -= size
		if _, err := m.Liquidity.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.Borrowed.Size()
		i -= size
		if _, err := m.Borrowed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.Collateral.Size()
		i -= size
		if _, err := m.Collateral.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.Reserved.Size()
		i -= size
		if _, err := m.Reserved.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.Supplied.Size()
		i -= size
		if _, err := m.Supplied.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.Borrow_APY.Size()
		i -= size
		if _, err := m.Borrow_APY.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.Supply_APY.Size()
		i -= size
		if _, err := m.Supply_APY.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.UTokenExchangeRate.Size()
		i -= size
		if _, err := m.UTokenExchangeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.OraclePrice != nil {
		{
			size := m.OraclePrice.Size()
			i -= size
			if _, err := m.OraclePrice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Exponent != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Exponent))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SymbolDenom) > 0 {
		i -= len(m.SymbolDenom)
		copy(dAtA[i:], m.SymbolDenom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SymbolDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAccountBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAccountBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAccountBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAccountBalancesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAccountBalancesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAccountBalancesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Borrowed) > 0 {
		for iNdEx := len(m.Borrowed) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Borrowed[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Collateral) > 0 {
		for iNdEx := len(m.Collateral) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Collateral[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Supplied) > 0 {
		for iNdEx := len(m.Supplied) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Supplied[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryAccountSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAccountSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAccountSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAccountSummaryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAccountSummaryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAccountSummaryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SpotBorrowedValue.Size()
		i -= size
		if _, err := m.SpotBorrowedValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.SpotCollateralValue.Size()
		i -= size
		if _, err := m.SpotCollateralValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.SpotSuppliedValue.Size()
		i -= size
		if _, err := m.SpotSuppliedValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.LiquidationThreshold != nil {
		{
			size := m.LiquidationThreshold.Size()
			i -= size
			if _, err := m.LiquidationThreshold.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.BorrowLimit != nil {
		{
			size := m.BorrowLimit.Size()
			i -= size
			if _, err := m.BorrowLimit.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.BorrowedValue.Size()
		i -= size
		if _, err := m.BorrowedValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.CollateralValue.Size()
		i -= size
		if _, err := m.CollateralValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.SuppliedValue.Size()
		i -= size
		if _, err := m.SuppliedValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryLiquidationTargets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLiquidationTargets) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLiquidationTargets) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryLiquidationTargetsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLiquidationTargetsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLiquidationTargetsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Targets[iNdEx])
			copy(dAtA[i:], m.Targets[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Targets[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryBadDebts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBadDebts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBadDebts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryBadDebtsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBadDebtsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBadDebtsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Targets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryMaxWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMaxWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMaxWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryMaxWithdrawResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMaxWithdrawResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMaxWithdrawResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tokens) > 0 {
		for iNdEx := len(m.Tokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.UTokens) > 0 {
		for iNdEx := len(m.UTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryMaxBorrow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMaxBorrow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMaxBorrow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryMaxBorrowResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMaxBorrowResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMaxBorrowResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tokens) > 0 {
		for iNdEx := len(m.Tokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryInspect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryInspect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryInspect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ltv != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Ltv))))
		i--
		dAtA[i] = 0x29
	}
	if m.Danger != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Danger))))
		i--
		dAtA[i] = 0x21
	}
	if m.Collateral != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Collateral))))
		i--
		dAtA[i] = 0x19
	}
	if m.Borrowed != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Borrowed))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryInspectAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryInspectAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryInspectAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryInspectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryInspectResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryInspectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Failures) > 0 {
		for iNdEx := len(m.Failures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Failures[iNdEx])
			copy(dAtA[i:], m.Failures[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Failures[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Borrowers) > 0 {
		for iNdEx := len(m.Borrowers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Borrowers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryInspectAccountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryInspectAccountResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryInspectAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Borrower.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InspectAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0x22
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Analysis != nil {
		{
			size, err := m.Analysis.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RiskInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RiskInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RiskInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i--
		dAtA[i] = 0x19
	}
	if m.Liquidation != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Liquidation))))
		i--
		dAtA[i] = 0x11
	}
	if m.Borrowed != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Borrowed))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *DecBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Borrowed) > 0 {
		for iNdEx := len(m.Borrowed) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Borrowed[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Collateral) > 0 {
		for iNdEx := len(m.Collateral) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Collateral[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryRegisteredTokens) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryRegisteredTokensResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Registry) > 0 {
		for _, e := range m.Registry {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryRegisteredTokensWithMarkets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryRegisteredTokensWithMarketsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Markets) > 0 {
		for _, e := range m.Markets {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *TokenMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Token.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Market.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QuerySpecialAssets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySpecialAssetsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pairs) > 0 {
		for _, e := range m.Pairs {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryMarketSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryMarketSummaryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SymbolDenom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Exponent != 0 {
		n += 1 + sovQuery(uint64(m.Exponent))
	}
	if m.OraclePrice != nil {
		l = m.OraclePrice.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.UTokenExchangeRate.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Supply_APY.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Borrow_APY.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Supplied.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Reserved.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Collateral.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Borrowed.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Liquidity.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.MaximumBorrow.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.MaximumCollateral.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.MinimumLiquidity.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.UTokenSupply.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.AvailableBorrow.Size()
	n += 2 + l + sovQuery(uint64(l))
	l = m.AvailableWithdraw.Size()
	n += 2 + l + sovQuery(uint64(l))
	l = m.AvailableCollateralize.Size()
	n += 2 + l + sovQuery(uint64(l))
	if m.OracleHistoricPrice != nil {
		l = m.OracleHistoricPrice.Size()
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.Errors)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAccountBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAccountBalancesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Supplied) > 0 {
		for _, e := range m.Supplied {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Collateral) > 0 {
		for _, e := range m.Collateral {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Borrowed) > 0 {
		for _, e := range m.Borrowed {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryAccountSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAccountSummaryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SuppliedValue.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.CollateralValue.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.BorrowedValue.Size()
	n += 1 + l + sovQuery(uint64(l))
	if m.BorrowLimit != nil {
		l = m.BorrowLimit.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.LiquidationThreshold != nil {
		l = m.LiquidationThreshold.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.SpotSuppliedValue.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.SpotCollateralValue.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.SpotBorrowedValue.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryLiquidationTargets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryLiquidationTargetsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, s := range m.Targets {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryBadDebts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryBadDebtsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryMaxWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryMaxWithdrawResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UTokens) > 0 {
		for _, e := range m.UTokens {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Tokens) > 0 {
		for _, e := range m.Tokens {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryMaxBorrow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryMaxBorrowResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tokens) > 0 {
		for _, e := range m.Tokens {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryInspect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Borrowed != 0 {
		n += 9
	}
	if m.Collateral != 0 {
		n += 9
	}
	if m.Danger != 0 {
		n += 9
	}
	if m.Ltv != 0 {
		n += 9
	}
	return n
}

func (m *QueryInspectAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryInspectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Borrowers) > 0 {
		for _, e := range m.Borrowers {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Failures) > 0 {
		for _, s := range m.Failures {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryInspectAccountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Borrower.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *InspectAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Analysis != nil {
		l = m.Analysis.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *RiskInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Borrowed != 0 {
		n += 9
	}
	if m.Liquidation != 0 {
		n += 9
	}
	if m.Value != 0 {
		n += 9
	}
	return n
}

func (m *DecBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Collateral) > 0 {
		for _, e := range m.Collateral {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Borrowed) > 0 {
		for _, e := range m.Borrowed {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRegisteredTokens) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRegisteredTokens: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRegisteredTokens: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRegisteredTokensResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRegisteredTokensResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRegisteredTokensResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Registry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Registry = append(m.Registry, Token{})
			if err := m.Registry[len(m.Registry)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRegisteredTokensWithMarkets) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRegisteredTokensWithMarkets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRegisteredTokensWithMarkets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRegisteredTokensWithMarketsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRegisteredTokensWithMarketsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRegisteredTokensWithMarketsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Markets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Markets = append(m.Markets, TokenMarket{})
			if err := m.Markets[len(m.Markets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Market.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpecialAssets) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySpecialAssets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySpecialAssets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpecialAssetsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySpecialAssetsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySpecialAssetsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pairs = append(m.Pairs, SpecialAssetPair{})
			if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMarketSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMarketSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMarketSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMarketSummaryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMarketSummaryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMarketSummaryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SymbolDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SymbolDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exponent", wireType)
			}
			m.Exponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exponent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OraclePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.OraclePrice = &v
			if err := m.OraclePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UTokenExchangeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UTokenExchangeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supply_APY", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Supply_APY.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Borrow_APY", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Borrow_APY.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supplied", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Supplied.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Reserved.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Borrowed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Borrowed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liquidity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Liquidity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumBorrow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaximumBorrow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumCollateral", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaximumCollateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumLiquidity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinimumLiquidity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UTokenSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UTokenSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableBorrow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AvailableBorrow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableWithdraw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AvailableWithdraw.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableCollateralize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AvailableCollateralize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleHistoricPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.OracleHistoricPrice = &v
			if err := m.OracleHistoricPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAccountBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAccountBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAccountBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAccountBalancesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAccountBalancesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAccountBalancesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supplied", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Supplied = append(m.Supplied, types.Coin{})
			if err := m.Supplied[len(m.Supplied)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collateral = append(m.Collateral, types.Coin{})
			if err := m.Collateral[len(m.Collateral)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Borrowed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Borrowed = append(m.Borrowed, types.Coin{})
			if err := m.Borrowed[len(m.Borrowed)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAccountSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAccountSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAccountSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAccountSummaryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAccountSummaryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAccountSummaryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuppliedValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SuppliedValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowedValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BorrowedValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.BorrowLimit = &v
			if err := m.BorrowLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.LiquidationThreshold = &v
			if err := m.LiquidationThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotSuppliedValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SpotSuppliedValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotCollateralValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SpotCollateralValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotBorrowedValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SpotBorrowedValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryLiquidationTargets) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLiquidationTargets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLiquidationTargets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryLiquidationTargetsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLiquidationTargetsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLiquidationTargetsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBadDebts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBadDebts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBadDebts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBadDebtsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBadDebtsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBadDebtsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, BadDebt{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMaxWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMaxWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMaxWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMaxWithdrawResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMaxWithdrawResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMaxWithdrawResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UTokens = append(m.UTokens, types.Coin{})
			if err := m.UTokens[len(m.UTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokens = append(m.Tokens, types.Coin{})
			if err := m.Tokens[len(m.Tokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMaxBorrow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMaxBorrow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMaxBorrow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMaxBorrowResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMaxBorrowResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMaxBorrowResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokens = append(m.Tokens, types.Coin{})
			if err := m.Tokens[len(m.Tokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryInspect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryInspect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryInspect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Borrowed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Borrowed = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Collateral = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Danger", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Danger = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ltv", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Ltv = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryInspectAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryInspectAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryInspectAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryInspectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryInspectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryInspectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Borrowers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Borrowers = append(m.Borrowers, InspectAccount{})
			if err := m.Borrowers[len(m.Borrowers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Failures = append(m.Failures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryInspectAccountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryInspectAccountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryInspectAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Borrower", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Borrower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Analysis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Analysis == nil {
				m.Analysis = &RiskInfo{}
			}
			if err := m.Analysis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &DecBalances{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RiskInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RiskInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RiskInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Borrowed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Borrowed = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liquidation", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Liquidation = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collateral = append(m.Collateral, types.DecCoin{})
			if err := m.Collateral[len(m.Collateral)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Borrowed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Borrowed = append(m.Borrowed, types.DecCoin{})
			if err := m.Borrowed[len(m.Borrowed)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
