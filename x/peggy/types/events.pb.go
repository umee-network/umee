// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: injective/peggy/v1/events.proto

package types

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EventAttestationObserved struct {
	AttestationType ClaimType `protobuf:"varint,1,opt,name=attestation_type,json=attestationType,proto3,enum=injective.peggy.v1.ClaimType" json:"attestation_type,omitempty"`
	BridgeContract  string    `protobuf:"bytes,2,opt,name=bridge_contract,json=bridgeContract,proto3" json:"bridge_contract,omitempty"`
	BridgeChainId   uint64    `protobuf:"varint,3,opt,name=bridge_chain_id,json=bridgeChainId,proto3" json:"bridge_chain_id,omitempty"`
	AttestationId   []byte    `protobuf:"bytes,4,opt,name=attestation_id,json=attestationId,proto3" json:"attestation_id,omitempty"`
	Nonce           uint64    `protobuf:"varint,5,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *EventAttestationObserved) Reset()         { *m = EventAttestationObserved{} }
func (m *EventAttestationObserved) String() string { return proto.CompactTextString(m) }
func (*EventAttestationObserved) ProtoMessage()    {}
func (*EventAttestationObserved) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{0}
}
func (m *EventAttestationObserved) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAttestationObserved) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAttestationObserved.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAttestationObserved) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAttestationObserved.Merge(m, src)
}
func (m *EventAttestationObserved) XXX_Size() int {
	return m.Size()
}
func (m *EventAttestationObserved) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAttestationObserved.DiscardUnknown(m)
}

var xxx_messageInfo_EventAttestationObserved proto.InternalMessageInfo

func (m *EventAttestationObserved) GetAttestationType() ClaimType {
	if m != nil {
		return m.AttestationType
	}
	return CLAIM_TYPE_UNKNOWN
}

func (m *EventAttestationObserved) GetBridgeContract() string {
	if m != nil {
		return m.BridgeContract
	}
	return ""
}

func (m *EventAttestationObserved) GetBridgeChainId() uint64 {
	if m != nil {
		return m.BridgeChainId
	}
	return 0
}

func (m *EventAttestationObserved) GetAttestationId() []byte {
	if m != nil {
		return m.AttestationId
	}
	return nil
}

func (m *EventAttestationObserved) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type EventBridgeWithdrawCanceled struct {
	BridgeContract string `protobuf:"bytes,1,opt,name=bridge_contract,json=bridgeContract,proto3" json:"bridge_contract,omitempty"`
	BridgeChainId  uint64 `protobuf:"varint,2,opt,name=bridge_chain_id,json=bridgeChainId,proto3" json:"bridge_chain_id,omitempty"`
}

func (m *EventBridgeWithdrawCanceled) Reset()         { *m = EventBridgeWithdrawCanceled{} }
func (m *EventBridgeWithdrawCanceled) String() string { return proto.CompactTextString(m) }
func (*EventBridgeWithdrawCanceled) ProtoMessage()    {}
func (*EventBridgeWithdrawCanceled) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{1}
}
func (m *EventBridgeWithdrawCanceled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBridgeWithdrawCanceled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBridgeWithdrawCanceled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBridgeWithdrawCanceled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBridgeWithdrawCanceled.Merge(m, src)
}
func (m *EventBridgeWithdrawCanceled) XXX_Size() int {
	return m.Size()
}
func (m *EventBridgeWithdrawCanceled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBridgeWithdrawCanceled.DiscardUnknown(m)
}

var xxx_messageInfo_EventBridgeWithdrawCanceled proto.InternalMessageInfo

func (m *EventBridgeWithdrawCanceled) GetBridgeContract() string {
	if m != nil {
		return m.BridgeContract
	}
	return ""
}

func (m *EventBridgeWithdrawCanceled) GetBridgeChainId() uint64 {
	if m != nil {
		return m.BridgeChainId
	}
	return 0
}

type EventBridgeWithdrawalReceived struct {
	BridgeContract string `protobuf:"bytes,1,opt,name=bridge_contract,json=bridgeContract,proto3" json:"bridge_contract,omitempty"`
	BridgeChainId  uint64 `protobuf:"varint,2,opt,name=bridge_chain_id,json=bridgeChainId,proto3" json:"bridge_chain_id,omitempty"`
	OutgoingTxId   uint64 `protobuf:"varint,3,opt,name=outgoing_tx_id,json=outgoingTxId,proto3" json:"outgoing_tx_id,omitempty"`
	Nonce          uint64 `protobuf:"varint,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *EventBridgeWithdrawalReceived) Reset()         { *m = EventBridgeWithdrawalReceived{} }
func (m *EventBridgeWithdrawalReceived) String() string { return proto.CompactTextString(m) }
func (*EventBridgeWithdrawalReceived) ProtoMessage()    {}
func (*EventBridgeWithdrawalReceived) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{2}
}
func (m *EventBridgeWithdrawalReceived) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBridgeWithdrawalReceived) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBridgeWithdrawalReceived.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBridgeWithdrawalReceived) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBridgeWithdrawalReceived.Merge(m, src)
}
func (m *EventBridgeWithdrawalReceived) XXX_Size() int {
	return m.Size()
}
func (m *EventBridgeWithdrawalReceived) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBridgeWithdrawalReceived.DiscardUnknown(m)
}

var xxx_messageInfo_EventBridgeWithdrawalReceived proto.InternalMessageInfo

func (m *EventBridgeWithdrawalReceived) GetBridgeContract() string {
	if m != nil {
		return m.BridgeContract
	}
	return ""
}

func (m *EventBridgeWithdrawalReceived) GetBridgeChainId() uint64 {
	if m != nil {
		return m.BridgeChainId
	}
	return 0
}

func (m *EventBridgeWithdrawalReceived) GetOutgoingTxId() uint64 {
	if m != nil {
		return m.OutgoingTxId
	}
	return 0
}

func (m *EventBridgeWithdrawalReceived) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type EventOutgoingBatch struct {
	BridgeContract string `protobuf:"bytes,1,opt,name=bridge_contract,json=bridgeContract,proto3" json:"bridge_contract,omitempty"`
	BridgeChainId  uint64 `protobuf:"varint,2,opt,name=bridge_chain_id,json=bridgeChainId,proto3" json:"bridge_chain_id,omitempty"`
	BatchId        uint64 `protobuf:"varint,3,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	Nonce          uint64 `protobuf:"varint,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *EventOutgoingBatch) Reset()         { *m = EventOutgoingBatch{} }
func (m *EventOutgoingBatch) String() string { return proto.CompactTextString(m) }
func (*EventOutgoingBatch) ProtoMessage()    {}
func (*EventOutgoingBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{3}
}
func (m *EventOutgoingBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOutgoingBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOutgoingBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOutgoingBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOutgoingBatch.Merge(m, src)
}
func (m *EventOutgoingBatch) XXX_Size() int {
	return m.Size()
}
func (m *EventOutgoingBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOutgoingBatch.DiscardUnknown(m)
}

var xxx_messageInfo_EventOutgoingBatch proto.InternalMessageInfo

func (m *EventOutgoingBatch) GetBridgeContract() string {
	if m != nil {
		return m.BridgeContract
	}
	return ""
}

func (m *EventOutgoingBatch) GetBridgeChainId() uint64 {
	if m != nil {
		return m.BridgeChainId
	}
	return 0
}

func (m *EventOutgoingBatch) GetBatchId() uint64 {
	if m != nil {
		return m.BatchId
	}
	return 0
}

func (m *EventOutgoingBatch) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type EventOutgoingBatchCanceled struct {
	BridgeContract string `protobuf:"bytes,1,opt,name=bridge_contract,json=bridgeContract,proto3" json:"bridge_contract,omitempty"`
	BridgeChainId  uint64 `protobuf:"varint,2,opt,name=bridge_chain_id,json=bridgeChainId,proto3" json:"bridge_chain_id,omitempty"`
	BatchId        uint64 `protobuf:"varint,3,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	Nonce          uint64 `protobuf:"varint,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *EventOutgoingBatchCanceled) Reset()         { *m = EventOutgoingBatchCanceled{} }
func (m *EventOutgoingBatchCanceled) String() string { return proto.CompactTextString(m) }
func (*EventOutgoingBatchCanceled) ProtoMessage()    {}
func (*EventOutgoingBatchCanceled) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{4}
}
func (m *EventOutgoingBatchCanceled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOutgoingBatchCanceled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOutgoingBatchCanceled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOutgoingBatchCanceled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOutgoingBatchCanceled.Merge(m, src)
}
func (m *EventOutgoingBatchCanceled) XXX_Size() int {
	return m.Size()
}
func (m *EventOutgoingBatchCanceled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOutgoingBatchCanceled.DiscardUnknown(m)
}

var xxx_messageInfo_EventOutgoingBatchCanceled proto.InternalMessageInfo

func (m *EventOutgoingBatchCanceled) GetBridgeContract() string {
	if m != nil {
		return m.BridgeContract
	}
	return ""
}

func (m *EventOutgoingBatchCanceled) GetBridgeChainId() uint64 {
	if m != nil {
		return m.BridgeChainId
	}
	return 0
}

func (m *EventOutgoingBatchCanceled) GetBatchId() uint64 {
	if m != nil {
		return m.BatchId
	}
	return 0
}

func (m *EventOutgoingBatchCanceled) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type EventMultisigUpdateRequest struct {
	BridgeContract string `protobuf:"bytes,1,opt,name=bridge_contract,json=bridgeContract,proto3" json:"bridge_contract,omitempty"`
	BridgeChainId  uint64 `protobuf:"varint,2,opt,name=bridge_chain_id,json=bridgeChainId,proto3" json:"bridge_chain_id,omitempty"`
	MultisigId     uint64 `protobuf:"varint,3,opt,name=multisig_id,json=multisigId,proto3" json:"multisig_id,omitempty"`
	Nonce          uint64 `protobuf:"varint,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *EventMultisigUpdateRequest) Reset()         { *m = EventMultisigUpdateRequest{} }
func (m *EventMultisigUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*EventMultisigUpdateRequest) ProtoMessage()    {}
func (*EventMultisigUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{5}
}
func (m *EventMultisigUpdateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMultisigUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMultisigUpdateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMultisigUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMultisigUpdateRequest.Merge(m, src)
}
func (m *EventMultisigUpdateRequest) XXX_Size() int {
	return m.Size()
}
func (m *EventMultisigUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMultisigUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EventMultisigUpdateRequest proto.InternalMessageInfo

func (m *EventMultisigUpdateRequest) GetBridgeContract() string {
	if m != nil {
		return m.BridgeContract
	}
	return ""
}

func (m *EventMultisigUpdateRequest) GetBridgeChainId() uint64 {
	if m != nil {
		return m.BridgeChainId
	}
	return 0
}

func (m *EventMultisigUpdateRequest) GetMultisigId() uint64 {
	if m != nil {
		return m.MultisigId
	}
	return 0
}

func (m *EventMultisigUpdateRequest) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type EventSetOrchestratorAddresses struct {
	SetOperatorAddress []byte `protobuf:"bytes,1,opt,name=set_operator_address,json=setOperatorAddress,proto3" json:"set_operator_address,omitempty"`
}

func (m *EventSetOrchestratorAddresses) Reset()         { *m = EventSetOrchestratorAddresses{} }
func (m *EventSetOrchestratorAddresses) String() string { return proto.CompactTextString(m) }
func (*EventSetOrchestratorAddresses) ProtoMessage()    {}
func (*EventSetOrchestratorAddresses) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{6}
}
func (m *EventSetOrchestratorAddresses) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSetOrchestratorAddresses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSetOrchestratorAddresses.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSetOrchestratorAddresses) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSetOrchestratorAddresses.Merge(m, src)
}
func (m *EventSetOrchestratorAddresses) XXX_Size() int {
	return m.Size()
}
func (m *EventSetOrchestratorAddresses) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSetOrchestratorAddresses.DiscardUnknown(m)
}

var xxx_messageInfo_EventSetOrchestratorAddresses proto.InternalMessageInfo

func (m *EventSetOrchestratorAddresses) GetSetOperatorAddress() []byte {
	if m != nil {
		return m.SetOperatorAddress
	}
	return nil
}

type EventValsetConfirm struct {
	ValsetConfirmKey []byte `protobuf:"bytes,1,opt,name=valset_confirm_key,json=valsetConfirmKey,proto3" json:"valset_confirm_key,omitempty"`
}

func (m *EventValsetConfirm) Reset()         { *m = EventValsetConfirm{} }
func (m *EventValsetConfirm) String() string { return proto.CompactTextString(m) }
func (*EventValsetConfirm) ProtoMessage()    {}
func (*EventValsetConfirm) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{7}
}
func (m *EventValsetConfirm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventValsetConfirm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventValsetConfirm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventValsetConfirm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventValsetConfirm.Merge(m, src)
}
func (m *EventValsetConfirm) XXX_Size() int {
	return m.Size()
}
func (m *EventValsetConfirm) XXX_DiscardUnknown() {
	xxx_messageInfo_EventValsetConfirm.DiscardUnknown(m)
}

var xxx_messageInfo_EventValsetConfirm proto.InternalMessageInfo

func (m *EventValsetConfirm) GetValsetConfirmKey() []byte {
	if m != nil {
		return m.ValsetConfirmKey
	}
	return nil
}

type EventSendToEth struct {
	OutgoingTxId uint64 `protobuf:"varint,1,opt,name=outgoing_tx_id,json=outgoingTxId,proto3" json:"outgoing_tx_id,omitempty"`
}

func (m *EventSendToEth) Reset()         { *m = EventSendToEth{} }
func (m *EventSendToEth) String() string { return proto.CompactTextString(m) }
func (*EventSendToEth) ProtoMessage()    {}
func (*EventSendToEth) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{8}
}
func (m *EventSendToEth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSendToEth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSendToEth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSendToEth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSendToEth.Merge(m, src)
}
func (m *EventSendToEth) XXX_Size() int {
	return m.Size()
}
func (m *EventSendToEth) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSendToEth.DiscardUnknown(m)
}

var xxx_messageInfo_EventSendToEth proto.InternalMessageInfo

func (m *EventSendToEth) GetOutgoingTxId() uint64 {
	if m != nil {
		return m.OutgoingTxId
	}
	return 0
}

type EventRequestBatch struct {
	BatchNonce uint64 `protobuf:"varint,1,opt,name=batch_nonce,json=batchNonce,proto3" json:"batch_nonce,omitempty"`
}

func (m *EventRequestBatch) Reset()         { *m = EventRequestBatch{} }
func (m *EventRequestBatch) String() string { return proto.CompactTextString(m) }
func (*EventRequestBatch) ProtoMessage()    {}
func (*EventRequestBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{9}
}
func (m *EventRequestBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRequestBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRequestBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRequestBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRequestBatch.Merge(m, src)
}
func (m *EventRequestBatch) XXX_Size() int {
	return m.Size()
}
func (m *EventRequestBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRequestBatch.DiscardUnknown(m)
}

var xxx_messageInfo_EventRequestBatch proto.InternalMessageInfo

func (m *EventRequestBatch) GetBatchNonce() uint64 {
	if m != nil {
		return m.BatchNonce
	}
	return 0
}

type EventConfirmBatch struct {
	BatchConfirmKey []byte `protobuf:"bytes,1,opt,name=batch_confirm_key,json=batchConfirmKey,proto3" json:"batch_confirm_key,omitempty"`
}

func (m *EventConfirmBatch) Reset()         { *m = EventConfirmBatch{} }
func (m *EventConfirmBatch) String() string { return proto.CompactTextString(m) }
func (*EventConfirmBatch) ProtoMessage()    {}
func (*EventConfirmBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{10}
}
func (m *EventConfirmBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventConfirmBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventConfirmBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventConfirmBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventConfirmBatch.Merge(m, src)
}
func (m *EventConfirmBatch) XXX_Size() int {
	return m.Size()
}
func (m *EventConfirmBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EventConfirmBatch.DiscardUnknown(m)
}

var xxx_messageInfo_EventConfirmBatch proto.InternalMessageInfo

func (m *EventConfirmBatch) GetBatchConfirmKey() []byte {
	if m != nil {
		return m.BatchConfirmKey
	}
	return nil
}

type EventDepositClaim struct {
	AttestationId []byte `protobuf:"bytes,1,opt,name=attestation_id,json=attestationId,proto3" json:"attestation_id,omitempty"`
}

func (m *EventDepositClaim) Reset()         { *m = EventDepositClaim{} }
func (m *EventDepositClaim) String() string { return proto.CompactTextString(m) }
func (*EventDepositClaim) ProtoMessage()    {}
func (*EventDepositClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{11}
}
func (m *EventDepositClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDepositClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDepositClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDepositClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDepositClaim.Merge(m, src)
}
func (m *EventDepositClaim) XXX_Size() int {
	return m.Size()
}
func (m *EventDepositClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDepositClaim.DiscardUnknown(m)
}

var xxx_messageInfo_EventDepositClaim proto.InternalMessageInfo

func (m *EventDepositClaim) GetAttestationId() []byte {
	if m != nil {
		return m.AttestationId
	}
	return nil
}

type EventWithdrawClaim struct {
	AttestationId []byte `protobuf:"bytes,1,opt,name=attestation_id,json=attestationId,proto3" json:"attestation_id,omitempty"`
}

func (m *EventWithdrawClaim) Reset()         { *m = EventWithdrawClaim{} }
func (m *EventWithdrawClaim) String() string { return proto.CompactTextString(m) }
func (*EventWithdrawClaim) ProtoMessage()    {}
func (*EventWithdrawClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{12}
}
func (m *EventWithdrawClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventWithdrawClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventWithdrawClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventWithdrawClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventWithdrawClaim.Merge(m, src)
}
func (m *EventWithdrawClaim) XXX_Size() int {
	return m.Size()
}
func (m *EventWithdrawClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_EventWithdrawClaim.DiscardUnknown(m)
}

var xxx_messageInfo_EventWithdrawClaim proto.InternalMessageInfo

func (m *EventWithdrawClaim) GetAttestationId() []byte {
	if m != nil {
		return m.AttestationId
	}
	return nil
}

type EventERC20DeployedClaim struct {
	AttestationId []byte `protobuf:"bytes,1,opt,name=attestation_id,json=attestationId,proto3" json:"attestation_id,omitempty"`
}

func (m *EventERC20DeployedClaim) Reset()         { *m = EventERC20DeployedClaim{} }
func (m *EventERC20DeployedClaim) String() string { return proto.CompactTextString(m) }
func (*EventERC20DeployedClaim) ProtoMessage()    {}
func (*EventERC20DeployedClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{13}
}
func (m *EventERC20DeployedClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventERC20DeployedClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventERC20DeployedClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventERC20DeployedClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventERC20DeployedClaim.Merge(m, src)
}
func (m *EventERC20DeployedClaim) XXX_Size() int {
	return m.Size()
}
func (m *EventERC20DeployedClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_EventERC20DeployedClaim.DiscardUnknown(m)
}

var xxx_messageInfo_EventERC20DeployedClaim proto.InternalMessageInfo

func (m *EventERC20DeployedClaim) GetAttestationId() []byte {
	if m != nil {
		return m.AttestationId
	}
	return nil
}

type EventValsetUpdateClaim struct {
	AttestationId []byte `protobuf:"bytes,1,opt,name=attestation_id,json=attestationId,proto3" json:"attestation_id,omitempty"`
}

func (m *EventValsetUpdateClaim) Reset()         { *m = EventValsetUpdateClaim{} }
func (m *EventValsetUpdateClaim) String() string { return proto.CompactTextString(m) }
func (*EventValsetUpdateClaim) ProtoMessage()    {}
func (*EventValsetUpdateClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{14}
}
func (m *EventValsetUpdateClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventValsetUpdateClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventValsetUpdateClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventValsetUpdateClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventValsetUpdateClaim.Merge(m, src)
}
func (m *EventValsetUpdateClaim) XXX_Size() int {
	return m.Size()
}
func (m *EventValsetUpdateClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_EventValsetUpdateClaim.DiscardUnknown(m)
}

var xxx_messageInfo_EventValsetUpdateClaim proto.InternalMessageInfo

func (m *EventValsetUpdateClaim) GetAttestationId() []byte {
	if m != nil {
		return m.AttestationId
	}
	return nil
}

type EventCancelSendToEth struct {
	OutgoingTxId uint64 `protobuf:"varint,1,opt,name=outgoing_tx_id,json=outgoingTxId,proto3" json:"outgoing_tx_id,omitempty"`
}

func (m *EventCancelSendToEth) Reset()         { *m = EventCancelSendToEth{} }
func (m *EventCancelSendToEth) String() string { return proto.CompactTextString(m) }
func (*EventCancelSendToEth) ProtoMessage()    {}
func (*EventCancelSendToEth) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{15}
}
func (m *EventCancelSendToEth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCancelSendToEth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCancelSendToEth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCancelSendToEth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCancelSendToEth.Merge(m, src)
}
func (m *EventCancelSendToEth) XXX_Size() int {
	return m.Size()
}
func (m *EventCancelSendToEth) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCancelSendToEth.DiscardUnknown(m)
}

var xxx_messageInfo_EventCancelSendToEth proto.InternalMessageInfo

func (m *EventCancelSendToEth) GetOutgoingTxId() uint64 {
	if m != nil {
		return m.OutgoingTxId
	}
	return 0
}

type EventSubmitBadSignatureEvidence struct {
	BadEthSignature        string `protobuf:"bytes,1,opt,name=bad_eth_signature,json=badEthSignature,proto3" json:"bad_eth_signature,omitempty"`
	BadEthSignatureSubject string `protobuf:"bytes,2,opt,name=bad_eth_signature_subject,json=badEthSignatureSubject,proto3" json:"bad_eth_signature_subject,omitempty"`
}

func (m *EventSubmitBadSignatureEvidence) Reset()         { *m = EventSubmitBadSignatureEvidence{} }
func (m *EventSubmitBadSignatureEvidence) String() string { return proto.CompactTextString(m) }
func (*EventSubmitBadSignatureEvidence) ProtoMessage()    {}
func (*EventSubmitBadSignatureEvidence) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{16}
}
func (m *EventSubmitBadSignatureEvidence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSubmitBadSignatureEvidence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSubmitBadSignatureEvidence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSubmitBadSignatureEvidence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSubmitBadSignatureEvidence.Merge(m, src)
}
func (m *EventSubmitBadSignatureEvidence) XXX_Size() int {
	return m.Size()
}
func (m *EventSubmitBadSignatureEvidence) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSubmitBadSignatureEvidence.DiscardUnknown(m)
}

var xxx_messageInfo_EventSubmitBadSignatureEvidence proto.InternalMessageInfo

func (m *EventSubmitBadSignatureEvidence) GetBadEthSignature() string {
	if m != nil {
		return m.BadEthSignature
	}
	return ""
}

func (m *EventSubmitBadSignatureEvidence) GetBadEthSignatureSubject() string {
	if m != nil {
		return m.BadEthSignatureSubject
	}
	return ""
}

func init() {
	proto.RegisterType((*EventAttestationObserved)(nil), "injective.peggy.v1.EventAttestationObserved")
	proto.RegisterType((*EventBridgeWithdrawCanceled)(nil), "injective.peggy.v1.EventBridgeWithdrawCanceled")
	proto.RegisterType((*EventBridgeWithdrawalReceived)(nil), "injective.peggy.v1.EventBridgeWithdrawalReceived")
	proto.RegisterType((*EventOutgoingBatch)(nil), "injective.peggy.v1.EventOutgoingBatch")
	proto.RegisterType((*EventOutgoingBatchCanceled)(nil), "injective.peggy.v1.EventOutgoingBatchCanceled")
	proto.RegisterType((*EventMultisigUpdateRequest)(nil), "injective.peggy.v1.EventMultisigUpdateRequest")
	proto.RegisterType((*EventSetOrchestratorAddresses)(nil), "injective.peggy.v1.EventSetOrchestratorAddresses")
	proto.RegisterType((*EventValsetConfirm)(nil), "injective.peggy.v1.EventValsetConfirm")
	proto.RegisterType((*EventSendToEth)(nil), "injective.peggy.v1.EventSendToEth")
	proto.RegisterType((*EventRequestBatch)(nil), "injective.peggy.v1.EventRequestBatch")
	proto.RegisterType((*EventConfirmBatch)(nil), "injective.peggy.v1.EventConfirmBatch")
	proto.RegisterType((*EventDepositClaim)(nil), "injective.peggy.v1.EventDepositClaim")
	proto.RegisterType((*EventWithdrawClaim)(nil), "injective.peggy.v1.EventWithdrawClaim")
	proto.RegisterType((*EventERC20DeployedClaim)(nil), "injective.peggy.v1.EventERC20DeployedClaim")
	proto.RegisterType((*EventValsetUpdateClaim)(nil), "injective.peggy.v1.EventValsetUpdateClaim")
	proto.RegisterType((*EventCancelSendToEth)(nil), "injective.peggy.v1.EventCancelSendToEth")
	proto.RegisterType((*EventSubmitBadSignatureEvidence)(nil), "injective.peggy.v1.EventSubmitBadSignatureEvidence")
}

func init() { proto.RegisterFile("injective/peggy/v1/events.proto", fileDescriptor_95f217691d2f42c2) }

var fileDescriptor_95f217691d2f42c2 = []byte{
	// 733 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0x4f, 0x6f, 0xd3, 0x4a,
	0x10, 0xef, 0xf6, 0xb5, 0xef, 0xcf, 0xb6, 0x4d, 0x5a, 0xab, 0xea, 0x4b, 0xfb, 0xd4, 0x24, 0x8a,
	0xfa, 0x20, 0x42, 0x90, 0xb4, 0x05, 0x21, 0xf1, 0x47, 0x2a, 0x4d, 0x1a, 0x89, 0xaa, 0x40, 0x84,
	0x5b, 0x40, 0xe2, 0x62, 0xad, 0xbd, 0x83, 0xbd, 0x90, 0x78, 0x8d, 0x77, 0x6d, 0x9a, 0x6f, 0xc0,
	0x91, 0x13, 0x47, 0x4e, 0x1c, 0xf9, 0x20, 0x1c, 0x7b, 0xe4, 0x88, 0xda, 0x6f, 0xc0, 0x27, 0x40,
	0x5e, 0x6f, 0x12, 0x8b, 0xa4, 0x12, 0x91, 0xda, 0xe3, 0xfe, 0x66, 0x7e, 0xb3, 0xbf, 0x9d, 0x99,
	0x9d, 0xc1, 0x25, 0xe6, 0xbf, 0x06, 0x47, 0xb2, 0x18, 0xea, 0x01, 0xb8, 0x6e, 0xaf, 0x1e, 0x6f,
	0xd5, 0x21, 0x06, 0x5f, 0x8a, 0x5a, 0x10, 0x72, 0xc9, 0x0d, 0x63, 0xe0, 0x50, 0x53, 0x0e, 0xb5,
	0x78, 0x6b, 0x6d, 0x63, 0x0c, 0x89, 0x48, 0x09, 0x42, 0x12, 0xc9, 0xb8, 0x9f, 0x32, 0x2b, 0x3f,
	0x10, 0x2e, 0xb4, 0x92, 0x50, 0xbb, 0x43, 0x53, 0xdb, 0x16, 0x10, 0xc6, 0x40, 0x8d, 0x87, 0x78,
	0x31, 0xc3, 0xb0, 0x64, 0x2f, 0x80, 0x02, 0x2a, 0xa3, 0x6a, 0x6e, 0x7b, 0xbd, 0x36, 0x7a, 0x63,
	0xad, 0xd9, 0x21, 0xac, 0x7b, 0xd4, 0x0b, 0xc0, 0xcc, 0x67, 0x68, 0x09, 0x60, 0x5c, 0xc5, 0x79,
	0x3b, 0x64, 0xd4, 0x05, 0xcb, 0xe1, 0xbe, 0x0c, 0x89, 0x23, 0x0b, 0xd3, 0x65, 0x54, 0xfd, 0xc7,
	0xcc, 0xa5, 0x70, 0x53, 0xa3, 0xc6, 0x95, 0xa1, 0xa3, 0x47, 0x98, 0x6f, 0x31, 0x5a, 0xf8, 0xa3,
	0x8c, 0xaa, 0x33, 0xe6, 0x82, 0x76, 0x4c, 0xd0, 0x7d, 0x6a, 0xfc, 0x8f, 0x73, 0x59, 0x69, 0x8c,
	0x16, 0x66, 0xca, 0xa8, 0x3a, 0x6f, 0x2e, 0x64, 0xd0, 0x7d, 0x6a, 0x2c, 0xe3, 0x59, 0x9f, 0xfb,
	0x0e, 0x14, 0x66, 0x55, 0x90, 0xf4, 0x50, 0xf1, 0xf1, 0x7f, 0xea, 0xcd, 0x0d, 0x15, 0xf2, 0x05,
	0x93, 0x1e, 0x0d, 0xc9, 0xbb, 0x26, 0xf1, 0x1d, 0xe8, 0x00, 0x1d, 0x27, 0x16, 0xfd, 0xae, 0xd8,
	0xe9, 0x31, 0x62, 0x2b, 0x5f, 0x10, 0x5e, 0x1f, 0x73, 0x21, 0xe9, 0x98, 0xe0, 0x00, 0x8b, 0x2f,
	0xe1, 0x4a, 0x63, 0x03, 0xe7, 0x78, 0x24, 0x5d, 0xce, 0x7c, 0xd7, 0x92, 0xc7, 0xc3, 0x34, 0xce,
	0xf7, 0xd1, 0xa3, 0xe3, 0x6c, 0x7a, 0x66, 0xb2, 0xe9, 0xf9, 0x88, 0xb0, 0xa1, 0xe4, 0xb6, 0xb5,
	0x6f, 0x83, 0x48, 0xc7, 0xbb, 0x78, 0x8d, 0xab, 0xf8, 0x6f, 0x3b, 0x89, 0x3c, 0x54, 0xf7, 0x97,
	0x3a, 0x9f, 0x2b, 0xec, 0x13, 0xc2, 0x6b, 0xa3, 0xc2, 0x2e, 0xad, 0x6e, 0x93, 0x0b, 0xfc, 0xdc,
	0x17, 0xf8, 0x38, 0xea, 0x48, 0x26, 0x98, 0xfb, 0x2c, 0xa0, 0x44, 0x82, 0x09, 0x6f, 0x23, 0x10,
	0xf2, 0xe2, 0x05, 0x96, 0xf0, 0x5c, 0x57, 0xdf, 0x34, 0xd4, 0x88, 0xfb, 0xd0, 0xb9, 0x32, 0x9f,
	0xea, 0x76, 0x3c, 0x04, 0xd9, 0x0e, 0x1d, 0x0f, 0x84, 0x0c, 0x89, 0xe4, 0xe1, 0x2e, 0xa5, 0x21,
	0x08, 0x01, 0xc2, 0xd8, 0xc4, 0xcb, 0x02, 0xa4, 0xc5, 0x03, 0x50, 0x06, 0x8b, 0xa4, 0x16, 0xa5,
	0x76, 0xde, 0x34, 0x04, 0xc8, 0xb6, 0x36, 0x69, 0x4e, 0xa5, 0xa1, 0x5b, 0xe6, 0x39, 0xe9, 0x08,
	0x90, 0x4d, 0xee, 0xbf, 0x62, 0x61, 0xd7, 0xb8, 0x8e, 0x8d, 0x58, 0x01, 0xc9, 0x83, 0x13, 0xc4,
	0x7a, 0x03, 0x3d, 0x1d, 0x65, 0x31, 0xce, 0xba, 0x1e, 0x40, 0xaf, 0x72, 0x1b, 0xe7, 0xb4, 0x2c,
	0x9f, 0x1e, 0xf1, 0x96, 0xf4, 0xc6, 0x74, 0x31, 0x1a, 0xed, 0xe2, 0xca, 0x2d, 0xbc, 0xa4, 0x78,
	0x3a, 0xcd, 0x69, 0xb7, 0x96, 0xf0, 0x5c, 0x5a, 0xbb, 0xf4, 0xfd, 0x29, 0x0f, 0x2b, 0xe8, 0x89,
	0x4a, 0xc2, 0x8e, 0x66, 0x69, 0x01, 0x29, 0xeb, 0x1a, 0x5e, 0x4a, 0x59, 0xa3, 0x7a, 0xf3, 0xca,
	0x90, 0x91, 0x7b, 0x57, 0x07, 0xd8, 0x83, 0x80, 0x0b, 0x26, 0xd5, 0xf4, 0x1b, 0x33, 0x97, 0xd0,
	0x98, 0xb9, 0x54, 0xb9, 0xa7, 0xd3, 0x35, 0x98, 0x3d, 0x93, 0x90, 0x1f, 0xe0, 0x7f, 0x15, 0xb9,
	0x65, 0x36, 0xb7, 0x37, 0xf7, 0x20, 0xe8, 0xf0, 0x1e, 0xd0, 0x89, 0x22, 0xec, 0xe0, 0x95, 0x4c,
	0xb5, 0xd2, 0x26, 0x9d, 0x28, 0xc0, 0x7d, 0xbc, 0x9c, 0x26, 0x4f, 0xfd, 0xbd, 0x49, 0x0b, 0xf6,
	0x1e, 0xe1, 0x52, 0x5a, 0xe9, 0xc8, 0xee, 0x32, 0xd9, 0x20, 0xf4, 0x90, 0xb9, 0x3e, 0x91, 0x51,
	0x08, 0xad, 0x98, 0x51, 0xf0, 0x1d, 0x48, 0x2b, 0x41, 0x2d, 0x90, 0x9e, 0x25, 0xfa, 0x46, 0xfd,
	0x5b, 0xf2, 0x36, 0xa1, 0x2d, 0xe9, 0x0d, 0x38, 0xc6, 0x1d, 0xbc, 0x3a, 0xe2, 0x6b, 0x89, 0xc8,
	0x4e, 0x36, 0x94, 0xde, 0x33, 0x2b, 0xbf, 0x70, 0x0e, 0x53, 0x6b, 0x03, 0xbe, 0x9e, 0x16, 0xd1,
	0xc9, 0x69, 0x11, 0x7d, 0x3f, 0x2d, 0xa2, 0x0f, 0x67, 0xc5, 0xa9, 0x93, 0xb3, 0xe2, 0xd4, 0xb7,
	0xb3, 0xe2, 0xd4, 0xcb, 0x03, 0x97, 0x49, 0x2f, 0xb2, 0x6b, 0x0e, 0xef, 0xd6, 0xf7, 0xfb, 0xcb,
	0xee, 0x11, 0xb1, 0x45, 0x7d, 0xb0, 0xfa, 0x6e, 0x38, 0x3c, 0x84, 0xec, 0x31, 0xf9, 0x96, 0xf5,
	0x2e, 0xa7, 0x51, 0x07, 0x84, 0xde, 0xba, 0xc9, 0xd2, 0x14, 0xf6, 0x9f, 0x6a, 0xdb, 0xde, 0xfc,
	0x19, 0x00, 0x00, 0xff, 0xff, 0x4e, 0x5c, 0x20, 0x6b, 0xca, 0x07, 0x00, 0x00,
}

func (m *EventAttestationObserved) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAttestationObserved) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAttestationObserved) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x28
	}
	if len(m.AttestationId) > 0 {
		i -= len(m.AttestationId)
		copy(dAtA[i:], m.AttestationId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AttestationId)))
		i--
		dAtA[i] = 0x22
	}
	if m.BridgeChainId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BridgeChainId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BridgeContract) > 0 {
		i -= len(m.BridgeContract)
		copy(dAtA[i:], m.BridgeContract)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BridgeContract)))
		i--
		dAtA[i] = 0x12
	}
	if m.AttestationType != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.AttestationType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventBridgeWithdrawCanceled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBridgeWithdrawCanceled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBridgeWithdrawCanceled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BridgeChainId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BridgeChainId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BridgeContract) > 0 {
		i -= len(m.BridgeContract)
		copy(dAtA[i:], m.BridgeContract)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BridgeContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBridgeWithdrawalReceived) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBridgeWithdrawalReceived) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBridgeWithdrawalReceived) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x20
	}
	if m.OutgoingTxId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OutgoingTxId))
		i--
		dAtA[i] = 0x18
	}
	if m.BridgeChainId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BridgeChainId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BridgeContract) > 0 {
		i -= len(m.BridgeContract)
		copy(dAtA[i:], m.BridgeContract)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BridgeContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventOutgoingBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOutgoingBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOutgoingBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x20
	}
	if m.BatchId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BatchId))
		i--
		dAtA[i] = 0x18
	}
	if m.BridgeChainId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BridgeChainId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BridgeContract) > 0 {
		i -= len(m.BridgeContract)
		copy(dAtA[i:], m.BridgeContract)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BridgeContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventOutgoingBatchCanceled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOutgoingBatchCanceled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOutgoingBatchCanceled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x20
	}
	if m.BatchId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BatchId))
		i--
		dAtA[i] = 0x18
	}
	if m.BridgeChainId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BridgeChainId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BridgeContract) > 0 {
		i -= len(m.BridgeContract)
		copy(dAtA[i:], m.BridgeContract)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BridgeContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMultisigUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMultisigUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMultisigUpdateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x20
	}
	if m.MultisigId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MultisigId))
		i--
		dAtA[i] = 0x18
	}
	if m.BridgeChainId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BridgeChainId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BridgeContract) > 0 {
		i -= len(m.BridgeContract)
		copy(dAtA[i:], m.BridgeContract)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BridgeContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSetOrchestratorAddresses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSetOrchestratorAddresses) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSetOrchestratorAddresses) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SetOperatorAddress) > 0 {
		i -= len(m.SetOperatorAddress)
		copy(dAtA[i:], m.SetOperatorAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SetOperatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventValsetConfirm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventValsetConfirm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventValsetConfirm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValsetConfirmKey) > 0 {
		i -= len(m.ValsetConfirmKey)
		copy(dAtA[i:], m.ValsetConfirmKey)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ValsetConfirmKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSendToEth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSendToEth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSendToEth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutgoingTxId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OutgoingTxId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventRequestBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRequestBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRequestBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BatchNonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BatchNonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventConfirmBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventConfirmBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventConfirmBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchConfirmKey) > 0 {
		i -= len(m.BatchConfirmKey)
		copy(dAtA[i:], m.BatchConfirmKey)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BatchConfirmKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventDepositClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDepositClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDepositClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttestationId) > 0 {
		i -= len(m.AttestationId)
		copy(dAtA[i:], m.AttestationId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AttestationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventWithdrawClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventWithdrawClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventWithdrawClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttestationId) > 0 {
		i -= len(m.AttestationId)
		copy(dAtA[i:], m.AttestationId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AttestationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventERC20DeployedClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventERC20DeployedClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventERC20DeployedClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttestationId) > 0 {
		i -= len(m.AttestationId)
		copy(dAtA[i:], m.AttestationId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AttestationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventValsetUpdateClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventValsetUpdateClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventValsetUpdateClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttestationId) > 0 {
		i -= len(m.AttestationId)
		copy(dAtA[i:], m.AttestationId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AttestationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCancelSendToEth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCancelSendToEth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCancelSendToEth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutgoingTxId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OutgoingTxId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventSubmitBadSignatureEvidence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSubmitBadSignatureEvidence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSubmitBadSignatureEvidence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BadEthSignatureSubject) > 0 {
		i -= len(m.BadEthSignatureSubject)
		copy(dAtA[i:], m.BadEthSignatureSubject)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BadEthSignatureSubject)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BadEthSignature) > 0 {
		i -= len(m.BadEthSignature)
		copy(dAtA[i:], m.BadEthSignature)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BadEthSignature)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventAttestationObserved) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttestationType != 0 {
		n += 1 + sovEvents(uint64(m.AttestationType))
	}
	l = len(m.BridgeContract)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BridgeChainId != 0 {
		n += 1 + sovEvents(uint64(m.BridgeChainId))
	}
	l = len(m.AttestationId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovEvents(uint64(m.Nonce))
	}
	return n
}

func (m *EventBridgeWithdrawCanceled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BridgeContract)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BridgeChainId != 0 {
		n += 1 + sovEvents(uint64(m.BridgeChainId))
	}
	return n
}

func (m *EventBridgeWithdrawalReceived) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BridgeContract)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BridgeChainId != 0 {
		n += 1 + sovEvents(uint64(m.BridgeChainId))
	}
	if m.OutgoingTxId != 0 {
		n += 1 + sovEvents(uint64(m.OutgoingTxId))
	}
	if m.Nonce != 0 {
		n += 1 + sovEvents(uint64(m.Nonce))
	}
	return n
}

func (m *EventOutgoingBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BridgeContract)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BridgeChainId != 0 {
		n += 1 + sovEvents(uint64(m.BridgeChainId))
	}
	if m.BatchId != 0 {
		n += 1 + sovEvents(uint64(m.BatchId))
	}
	if m.Nonce != 0 {
		n += 1 + sovEvents(uint64(m.Nonce))
	}
	return n
}

func (m *EventOutgoingBatchCanceled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BridgeContract)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BridgeChainId != 0 {
		n += 1 + sovEvents(uint64(m.BridgeChainId))
	}
	if m.BatchId != 0 {
		n += 1 + sovEvents(uint64(m.BatchId))
	}
	if m.Nonce != 0 {
		n += 1 + sovEvents(uint64(m.Nonce))
	}
	return n
}

func (m *EventMultisigUpdateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BridgeContract)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BridgeChainId != 0 {
		n += 1 + sovEvents(uint64(m.BridgeChainId))
	}
	if m.MultisigId != 0 {
		n += 1 + sovEvents(uint64(m.MultisigId))
	}
	if m.Nonce != 0 {
		n += 1 + sovEvents(uint64(m.Nonce))
	}
	return n
}

func (m *EventSetOrchestratorAddresses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SetOperatorAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventValsetConfirm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValsetConfirmKey)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventSendToEth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutgoingTxId != 0 {
		n += 1 + sovEvents(uint64(m.OutgoingTxId))
	}
	return n
}

func (m *EventRequestBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchNonce != 0 {
		n += 1 + sovEvents(uint64(m.BatchNonce))
	}
	return n
}

func (m *EventConfirmBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchConfirmKey)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventDepositClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AttestationId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventWithdrawClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AttestationId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventERC20DeployedClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AttestationId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventValsetUpdateClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AttestationId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventCancelSendToEth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutgoingTxId != 0 {
		n += 1 + sovEvents(uint64(m.OutgoingTxId))
	}
	return n
}

func (m *EventSubmitBadSignatureEvidence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BadEthSignature)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.BadEthSignatureSubject)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventAttestationObserved) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAttestationObserved: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAttestationObserved: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationType", wireType)
			}
			m.AttestationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttestationType |= ClaimType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BridgeContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeChainId", wireType)
			}
			m.BridgeChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BridgeChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationId = append(m.AttestationId[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationId == nil {
				m.AttestationId = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBridgeWithdrawCanceled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBridgeWithdrawCanceled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBridgeWithdrawCanceled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BridgeContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeChainId", wireType)
			}
			m.BridgeChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BridgeChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBridgeWithdrawalReceived) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBridgeWithdrawalReceived: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBridgeWithdrawalReceived: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BridgeContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeChainId", wireType)
			}
			m.BridgeChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BridgeChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutgoingTxId", wireType)
			}
			m.OutgoingTxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutgoingTxId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOutgoingBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOutgoingBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOutgoingBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BridgeContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeChainId", wireType)
			}
			m.BridgeChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BridgeChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			m.BatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOutgoingBatchCanceled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOutgoingBatchCanceled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOutgoingBatchCanceled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BridgeContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeChainId", wireType)
			}
			m.BridgeChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BridgeChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			m.BatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMultisigUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMultisigUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMultisigUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BridgeContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeChainId", wireType)
			}
			m.BridgeChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BridgeChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultisigId", wireType)
			}
			m.MultisigId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultisigId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSetOrchestratorAddresses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSetOrchestratorAddresses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSetOrchestratorAddresses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetOperatorAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetOperatorAddress = append(m.SetOperatorAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.SetOperatorAddress == nil {
				m.SetOperatorAddress = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventValsetConfirm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventValsetConfirm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventValsetConfirm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValsetConfirmKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValsetConfirmKey = append(m.ValsetConfirmKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ValsetConfirmKey == nil {
				m.ValsetConfirmKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSendToEth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSendToEth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSendToEth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutgoingTxId", wireType)
			}
			m.OutgoingTxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutgoingTxId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRequestBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRequestBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRequestBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchNonce", wireType)
			}
			m.BatchNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventConfirmBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventConfirmBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventConfirmBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchConfirmKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchConfirmKey = append(m.BatchConfirmKey[:0], dAtA[iNdEx:postIndex]...)
			if m.BatchConfirmKey == nil {
				m.BatchConfirmKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDepositClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDepositClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDepositClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationId = append(m.AttestationId[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationId == nil {
				m.AttestationId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventWithdrawClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventWithdrawClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventWithdrawClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationId = append(m.AttestationId[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationId == nil {
				m.AttestationId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventERC20DeployedClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventERC20DeployedClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventERC20DeployedClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationId = append(m.AttestationId[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationId == nil {
				m.AttestationId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventValsetUpdateClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventValsetUpdateClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventValsetUpdateClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationId = append(m.AttestationId[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationId == nil {
				m.AttestationId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCancelSendToEth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCancelSendToEth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCancelSendToEth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutgoingTxId", wireType)
			}
			m.OutgoingTxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutgoingTxId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSubmitBadSignatureEvidence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSubmitBadSignatureEvidence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSubmitBadSignatureEvidence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadEthSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadEthSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadEthSignatureSubject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadEthSignatureSubject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
